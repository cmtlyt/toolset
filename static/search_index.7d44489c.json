[{"id":0,"title":"斐波那契数列","content":"","routePath":"/toolset/daily/fib","lang":"","toc":[{"text":"解决方法","id":"解决方法","depth":2,"charIndex":-1},{"text":"递归","id":"递归","depth":2,"charIndex":-1},{"text":"优化","id":"优化","depth":3,"charIndex":-1},{"text":"函数导出","id":"函数导出","depth":3,"charIndex":-1},{"text":"reduce","id":"reduce","depth":2,"charIndex":-1},{"text":"生成器","id":"生成器","depth":2,"charIndex":-1},{"text":"自定义迭代器","id":"自定义迭代器","depth":3,"charIndex":-1},{"text":"完整code","id":"完整code","depth":2,"charIndex":-1},{"text":"知识点","id":"知识点","depth":2,"charIndex":-1},{"text":"闭包","id":"闭包","depth":3,"charIndex":-1},{"text":"模块导出","id":"模块导出","depth":3,"charIndex":-1},{"text":"分类","id":"分类","depth":4,"charIndex":-1},{"text":"总结","id":"总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"开发日常","content":"#","routePath":"/toolset/daily/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"元素居中方式","content":"#\n\n\n水平居中#\n\n分为 行内元素居中 和 块级元素居中\n\n 1. 行内元素：在父级元素的样式设置 text-align:center;\n\n 2. 块级元素：\n    \n    1. 固定宽度：目标元素样式设置 margin:0 auto;\n    \n    2. 不定宽度：\n       \n       1. 设置 table：\n          \n          \n       \n       2. 设置 inline-block：\n          \n          \n       \n       3. 设置 flex 布局：\n          \n          \n       \n       4. 设置 left + transform：\n          \n          \n          \n          > 如果目标元素有宽度还可以使用 margin-left: -(目标元素宽度)px 代替 transform，或者使用 margin:\n          > auto\n\n\n垂直居中#\n\n 1. 行内元素：\n    \n    1. 单行：将父元素的行高设置成高度一样： line-height = height\n    2. 多行：给父元素设置display: table-cell和vertical-align: middle\n\n 2. 块级元素：\n    \n    1. 设置 flex 布局\n       \n       \n    \n    2. position + top / bottom\n       \n       \n       \n       > transform中translate偏移的百分比就是相对于元素自身的尺寸而言的。\n\n\n水平垂直居中#\n\n 1. 绝对定位 + margin\n    \n    \n\n 2. 绝对定位 + 负margin(需要知道 宽高)\n    \n    \n\n 3. 绝对定位 + transform\n    \n    \n\n 4. flex 布局\n    \n    \n\n 5. table-cell\n    \n    ","routePath":"/toolset/daily/元素居中方式","lang":"","toc":[{"text":"水平居中","id":"水平居中","depth":2,"charIndex":3},{"text":"垂直居中","id":"垂直居中","depth":2,"charIndex":467},{"text":"水平垂直居中","id":"水平垂直居中","depth":2,"charIndex":758}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"var","content":"#\n\n在 ES6+ 之前变量的声明使用的是 var 关键字，但对于用 var 声明的变量，不管声明位置在哪里都会被提升到当前作用域的顶端，也成为变量提升。\n\n如果是在函数体内声明的话就会提升到函数的最前面，如果是在全局作用域下就会提升到全局的最前面。\n\n\n\n为什么只会输出 undefined ？因为 var 只会做声明的提升，具体的赋值还是会等到执行到那一行才会执行。\n\n\n\n而在 ES6+ 之后，为了解决变量提升这个问题，也称为暂时性死区，新增了 let 和 const 声明变量的关键字。\n\nINFO\n\n暂时性死区：在代码块内，使用 let 声明变量之前，该变量都是不可用的。\n\n\n\nconst 也不允许在声明之前使用变量， const 是用于声明作用域的局部常量，常量的值不能通过 赋值运算符(=)\n重新赋值改变，但如果常量是一个对象的话，它的属性可以被添加、更新或删除。\n\nINFO\n\n关于为什么常量是对象的话就可以修改属性呢？\n\n因为在对象（引用数据类型）中，使用 const 声明一个对象时声明的是一个对象的内存地址引用，不能通过赋值运算符重新赋值也就是不能改变这个引用去指向另一个对象。","routePath":"/toolset/daily/变量提升","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"定位元素","content":"#\n\n\n定位类型#\n\n类型         描述\nstatic     默认值，元素正常在文档流中，会忽略 top、bottom、left、right 或者 z-index等属性\nrelative   元素可以使用的顶部，底部，左侧和右侧属性定位\nabsolute   寻找 最近有定位(非 static ) 通过 top、bottom等属性进行定位\nfixed      相对于可视窗口固定定位\nsticky     相对定位和固定定位相结合，如果元素并不脱离文档流，仍然保留元素原本在文档流中的位置；当元素在容器中被滚动超过指定的偏移值\n           时，元素在容器内固定在指定位置；需要指定 top, right, bottom 或 left\n           四个阈值其中之一，才可使粘性定位生效，反之与相对定位相同\n\n\n定位失效#\n\nfixed失效\n\n> 定位的基准元素发生改变，此时任何非 none 的 transform 值都会导致一个堆叠上下文和包含块的创建。\n\n创建堆叠上下文的方式(参考自 MDN):\n\n * 根元素 (HTML)\n * z-index 值不为 \"auto\"的 绝对/相对定位\n * 一个 z-index 值不为 \"auto\"的 flex 项目 (flex item), 即: 父元素 display: flex|inline-flex\n * opacity 属性值小于 1 的元素（参考 the specification for opacity）\n * transform 属性值不为 \"none\"的元素\n * mix-blend-mode 属性值不为 \"normal\"的元素\n * filter值不为 \"none\" 的元素\n * perspective值不为 \"none\" 的元素,\n * isolation 属性被设置为 \"isolate\"的元素\n * position: fixed\n * 在 will-change 中指定了任意 CSS 属性, 即便你没有直接指定这些属性的值\n * -webkit-overflow-scrolling 属性被设置 \"touch\"的元素\n * backdrop-filter 值不为 \"none\" 的元素\n\n解决办法\n\n * 添加 transform: unset\n\n\n脱离文档流#\n\n文档流 指窗体元素自上而下一行一行，并在每行中从左至右以此排放元素，也叫普通流动。\n\n脱离文档流 指 元素不再在文档流中占据空间，而是处于浮动状态\n\n方式：\n\n 1. float\n\n 2. absolute\n\n 3. fixed","routePath":"/toolset/daily/定位元素","lang":"","toc":[{"text":"定位类型","id":"定位类型","depth":2,"charIndex":3},{"text":"定位失效","id":"定位失效","depth":2,"charIndex":370},{"text":"脱离文档流","id":"脱离文档流","depth":2,"charIndex":981}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"闭包","content":"#\n\n\n什么是闭包#\n\nMDN的解释如下：\n\n闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical\nenvironment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript\n中，闭包会随着函数的创建而被同时创建。\n\n\n\n上面的例子中，inner 函数就是引用了外层函数 outer 作用域中的变量 a。\n\n这种一般就是内部引用外部的变量，但如何在外部 引用 / 修改 内部的变量呢？\n\n\n外部修改内部值#\n\n 1. 暴露一个修改接口\n\n\n\n 1. 通过函数修改对象比如下面这道面试题：\n\n\n\n由于 ctrl 他是一个立即执行函数，所以拿到的其实就是 get(key){return a[key]} 这个函数，对于 a\n对象来说就是一个闭包。如果要尝试在外面修改 a 对象的属性，那第一步就是要拿到 a 对象，在 js 中如果当前对象没有某个属性，就会往 原型链 上找，一直找到\nObject.propotype ，所以可以在直接在 Object 的原型上加一个 b 属性。\n\n\n\n这样子就可以在找 a['b'] 的时候就会往原型链上找，由于 a 对象是通过字面量表示法。\n\n\n\n当找 a['b'] 属性值的时候，a 中没有这个字段，所以会找到 Object.prototype ，此时 Object.prototype.b = 1;\n就会返回数值 1。\n\n但这样子有一个弊端就是污染到了全局的对象，另外一个就是获取 ctrl 作用域里面的对象，然后在对象上加上 b 属性。\n\n\n\n\n原型链#\n\n原型：在 JavaScript 中，每个函数对象都会有一个 prototype 属性，这个属性指向函数的原型，也成为 原型对象。\n\n原型上可以存放 属性 或 方法，共享给 实例对象 使用，也可以做 继承。\n\n原型链：对象都会有一个 __proto__ 属性指向对象的 原型对象，同时 原型对象 也是对象也有 __proto__ 指向原型对象的对象，因此每一个对象的\n__proto__ 最终会指向到 Object.prototype.__proto__ 上面，表示原型链的顶端，而\nObject.prototype.__proto__ = null。\n\n\n\n\n\n如果这样子打印 b.name 的话，由于 b 中并没有 name 这个属性，所以会输出 undefined，但要是修改一下 b 的 __proto__ 指向呢？\n\n\n\n还是上面的步骤，b 中没有 name 属性，所以他会往原型链 __proto__ 属性找，这时候就找到了 a，a 中有 name 字段，所以输出的是 a 中\nname 的属性值。\n\n__proto__ 和 prototype 区别：\n\n 1. __proto__是每个对象（包括普通对象和函数对象）都有的一个属性，指向创建该对象的构造函数的原型对象。\n 2. prototype是构造函数独有属性，每个函数（作为构造函数）都有一个 prototype属性。\n 3. __proto__是对象的内部属性，prototype是构造函数的属性。\n\n原型链的相关方法：\n\n 1. Object.getPrototypeOf( ) ：查找一个对象的原型对象。\n 2. instanceof 操作符：判断一个对象是否是一个构造函数的实例。\n 3. isPrototypeOf( )：判断一个对象是否是另外一个对象的原型对象。\n 4. hasOwnProperty( )：判断一个属性是定义在对象本身还是从原型对象上继承得到的，如果是本身返回 true，如果是继承得到的返回 false。","routePath":"/toolset/daily/闭包","lang":"","toc":[{"text":"什么是闭包","id":"什么是闭包","depth":2,"charIndex":3},{"text":"外部修改内部值","id":"外部修改内部值","depth":2,"charIndex":232},{"text":"原型链","id":"原型链","depth":2,"charIndex":679}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"介绍","content":"#\n\n这是个开发基础库文档, 包含了很多的开发工具包, 会长久缓慢更新\n\n大家先上车后补票哈, 文档我会慢慢更新上来的","routePath":"/toolset/guides/","lang":"","toc":[],"domain":"","frontmatter":{"sidebar":false},"version":""},{"id":9,"title":"介绍","content":"#\n\n@cmtlyt/base 只是一个我的第一个工程, 之后还会有更多的工程被创建, 并且所有有价值的工具方法都会被放到这个包里, 大家可以多关注喔~\n\n大家先上车后补票哈, 文档我会慢慢更新上来的","routePath":"/toolset/packages/base/guide","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"更新日志记录","content":"#\n\n\n日志标识总览#\n\n * (O) 对象\n * (D) 目录\n * (F) 函数\n * (I) 接口\n * (CV) 常量\n * -> 别名\n\n\nv0.7.0#\n\n扩展更多工具类型\n\n! 循环依赖处理, 部分指定文件导入的模块会失效 例如: , 如果使用 的方式导入则不受本次修改的影响\n\n受影响的方法:\n\n * cacheByReturn\n * getAliAppEnv\n * getOsType\n * getDeviceInfo\n * getType\n * getUserAgent\n * isWeb\n * isNode\n * isMiniApp\n * isAliMiniApp\n * isByteDanceMicroApp\n * isWeChatMiniProgram\n * isWeex\n * isIOS\n * isAndroid\n * isOpenHarmony\n * isString\n * isUndef\n\n\nv0.6.9#\n\n对外暴露工具类型\n\n\nv0.6.8#\n\n修复 createWorkerFunc 传递函数依赖打包混淆后, 函数丢失问题\n\n\nv0.6.7#\n\n优化\n\n * createWorkerFunc 支持直接从传入函数作为依赖\n * getRandomString 从原来的 32 进制更新为 36 进制\n\n修复\n\n * createWorkerFunc 返回值类型修复\n\n\nv0.6.6#\n\n类型调整\n\n\nv0.6.5#\n\n新增\n\n * (D) utils\n   * (F) sleepSync\n\n修复一些小 bug\n\n\nv0.6.4#\n\n新增\n\n * (D) utils\n   * (F) reverseArgs\n   * (F) asyncFilter\n\n\nv0.6.1#\n\n函数所属目录调整\n\n\nv0.6.0#\n\n * 目录分类重构\n * 新增客户端检测\n * 使用 rollup 打包\n\n\nv0.5.17#\n\n优化\n\n * isUrl 支持 https 判断\n\n\nv0.5.16#\n\n优化\n\n * gc 类型优化\n\n\nv0.5.15#\n\n修改\n\n修复 merge 类型提示\n\n\nv0.5.14#\n\n修改\n\n添加友好的 merge 类型提示\n\n\nv0.5.13#\n\n新增\n\n * (D) utils\n   * (F) merge\n   * (F) cloneMerge\n\n\nv0.5.12#\n\n修改\n\ncreatePool 的所有权控制增强, 修改返回值类型\n\n\nv0.5.11#\n\n部分函数添加警告\n\n新增\n\n * createUploader 支持二进制上传,支持配置 headersHandler\n * (D) utils\n   * (F) sleep\n   * (F) asyncReplace\n   * (F) memoize\n   * (F) deepClone\n\n\nv0.5.10#\n\n全局添加可控警告 通过 window.__ClConfig__.disableWarning 控制\n\n\nv0.5.9#\n\n新增\n\n * (D) utils\n   * (F) chunkTask\n   * (F) isAsyncFunc\n\n修复\n\n * 修复 apply 方法传参错误问题\n\n优化\n\n * 优化 cacheByReturn 方法底层调用方式\n\n\nv0.5.8#\n\n新增\n\n * (D) utils\n   * (F) getNow\n\n\nv0.5.7#\n\n新增\n\n * (D) utils\n   * (F) getCallStack\n\n\nv0.5.6#\n\n新增\n\n * (D) utils\n   * (F) isTrue\n   * (F) isFalse\n\n修改\n\n * 所有 function 类改为 class 类\n * 所有私有属性和方法, 使用 ES6 的私有句法定义\n\n\nv0.5.5#\n\n新增\n\n * (D) utils\n   * (F) apply\n   * (F) construct\n   * (F) defineProperty\n   * (F) deleteProperty\n   * (F) get\n   * (F) getOwnPropertyDescriptor\n   * (F) getPrototypeOf\n   * (F) has\n   * (F) isExtensible\n   * (F) ownKeys\n   * (F) preventExtensions\n   * (F) set\n   * (F) setPrototypeOf\n * createUploader 支持用户自定义 fetch 参数\n\n\nv0.5.4#\n\n新增\n\n * createUploader 新增 concurrentNode 配置, 用于配制并发上传的节点\n\n\nv0.5.3#\n\n新增\n\n * Logger 新增 getInstance 静态方法\n\n修改\n\n * 部分类型修订\n * 移除多余类型\n * 移除 createStorePool 中的 DefaultStoreController 导出\n\n\nv0.5.2#\n\n新增\n\n * (F) createPool\n * (F) getPool\n\n修复\n\n * 部分类型修复\n\n优化\n\n * createUploader 使用 createPool 管理上传任务，并增加可配置参数\n\n\nv0.5.1#\n\n修复\n\n * 修复 isHttpUrlString 无法识别 // 开头链接的问题\n\n\nv0.5.0#\n\n新增\n\n * (F) createUploader\n * (D) utils\n   * (F) isFile\n   * (F) isBlob\n   * (F) isHttpUrlString\n   * (F) isBlobUrlString\n   * (F) isDataUrlString\n   * (F) isUrl\n   * (F) getArraySlice\n\n修复\n\n * logger 类型错误，及内部参数赋值错误\n * string 模块类型修复\n * 移除多余类型声明\n * createWorkerFunc 类型完善\n\n新增\n\n * createWorkerFunc 监听用户自己发送的事件\n\n备注\n\n * 如果 createWorkerFunc 第三个参数的 needPost 配置项被设置为 true 后，会改变 func 的第一个参数为\n   postMessage 函数，如果需要使用，请注意！！！\n\n\nv0.4.2#\n\n新增\n\n * (D) utils\n   * (F) isEmpty\n\n修复\n\n * 大范围类型修复\n * 修复 pipe 和 compose 写反了的问题\n * 修复 isEmpty 部分类型判断错误问题\n\n修改\n\n * generateCookieInfo 增加可配置参数\n\n\nv0.4.1#\n\n新增\n\n * (D) utils\n   * (F) getType\n\n修改\n\n * Calculator 的 valueOf 方法改为计算器的等于运算符，并新增 getCurrValue 来获取当前值，但不计算最终结果\n\n\n\n修复\n\n * 大范围类型修复\n\n\nv0.4.0#\n\n新增\n\n * (F) curry\n * (F) compose\n * (F) pipe\n\n警告\n\ncompose 和 pipe 类型存在缺陷，只能判断最后输入的函数是否满足条件，不能判断中间的函数\n也就是说从前往后传入函数可以正确判断类型，但是如果是在中间插入函数就不行，而且对于柯理化后的函数，只能判断第一个参数的类型\n\n\nv0.3.3#\n\n修复\n\n * 修复 clipboard.paste 返回类型不统一问题\n\n\nv0.3.2#\n\n修复\n\n * 修复 getArray 类型提示中返回类型错误问题\n\n\nv0.3.1#\n\n修复\n\n * 修复调用 getArray 出现找不到 isNull 的问题\n\n\nv0.3.0#\n\n新增\n\n * (O) cookie\n   * (F) get\n   * (F) set\n   * (F) remove\n * (D) utils\n   * (F) generateCookieInfo\n   * (F) generateClassName -> gc\n\n\nv0.2.0#\n\n新增\n\n * (F) createStorePool\n * (C) DefaultStoreController\n * (I) IStoreController\n * (C) EventEmitter\n * (C) CustomEvent\n * (O) clipboard\n   * (F) copy\n   * (F) paste\n   * (F) clear\n * (C) Calculator\n * (D) utils\n   * (F) debounce\n   * (F) throttle\n   * (F) isNumber\n   * (F) isNaN\n   * (F) isPromise\n\n\nv0.1.0#\n\n新增\n\n * (F) createWorkerFunc\n * (C) Logger\n * (D) utils\n   * (F) getArray\n   * (F) cacheByReturn\n   * (F) formatDate\n   * (F) getRandomString\n   * (F) createLinkByString\n   * (F) isNull\n * (CV) EMPTY","routePath":"/toolset/packages/base/history","lang":"","toc":[{"text":"日志标识总览","id":"日志标识总览","depth":3,"charIndex":3},{"text":"v0.7.0","id":"v070","depth":3,"charIndex":74},{"text":"v0.6.9","id":"v069","depth":3,"charIndex":413},{"text":"v0.6.8","id":"v068","depth":3,"charIndex":433},{"text":"v0.6.7","id":"v067","depth":3,"charIndex":484},{"text":"v0.6.6","id":"v066","depth":3,"charIndex":605},{"text":"v0.6.5","id":"v065","depth":3,"charIndex":621},{"text":"v0.6.4","id":"v064","depth":3,"charIndex":679},{"text":"v0.6.1","id":"v061","depth":3,"charIndex":749},{"text":"v0.6.0","id":"v060","depth":3,"charIndex":769},{"text":"v0.5.17","id":"v0517","depth":3,"charIndex":817},{"text":"v0.5.16","id":"v0516","depth":3,"charIndex":854},{"text":"v0.5.15","id":"v0515","depth":3,"charIndex":881},{"text":"v0.5.14","id":"v0514","depth":3,"charIndex":911},{"text":"v0.5.13","id":"v0513","depth":3,"charIndex":944},{"text":"v0.5.12","id":"v0512","depth":3,"charIndex":1008},{"text":"v0.5.11","id":"v0511","depth":3,"charIndex":1053},{"text":"v0.5.10","id":"v0510","depth":3,"charIndex":1211},{"text":"v0.5.9","id":"v059","depth":3,"charIndex":1273},{"text":"v0.5.8","id":"v058","depth":3,"charIndex":1401},{"text":"v0.5.7","id":"v057","depth":3,"charIndex":1445},{"text":"v0.5.6","id":"v056","depth":3,"charIndex":1495},{"text":"v0.5.5","id":"v055","depth":3,"charIndex":1617},{"text":"v0.5.4","id":"v054","depth":3,"charIndex":1949},{"text":"v0.5.3","id":"v053","depth":3,"charIndex":2016},{"text":"v0.5.2","id":"v052","depth":3,"charIndex":2137},{"text":"v0.5.1","id":"v051","depth":3,"charIndex":2253},{"text":"v0.5.0","id":"v050","depth":3,"charIndex":2306},{"text":"v0.4.2","id":"v042","depth":3,"charIndex":2730},{"text":"v0.4.1","id":"v041","depth":3,"charIndex":2879},{"text":"v0.4.0","id":"v040","depth":3,"charIndex":3018},{"text":"v0.3.3","id":"v033","depth":3,"charIndex":3190},{"text":"v0.3.2","id":"v032","depth":3,"charIndex":3237},{"text":"v0.3.1","id":"v031","depth":3,"charIndex":3281},{"text":"v0.3.0","id":"v030","depth":3,"charIndex":3330},{"text":"v0.2.0","id":"v020","depth":3,"charIndex":3475},{"text":"v0.1.0","id":"v010","depth":3,"charIndex":3786}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"计算器","content":"#\n\n\nCalculator - (class)#\n\n计算器, 支持加减乘除和括号, 支持链式调用\n\n\n静态方法#\n\n\n\n\n参数#\n\n必填   参数名         说明     类型       默认值\n     initValue   初始化值   number   0\n\n\n返回值#\n\nCalculator 实例\n\n\n实例方法#\n\n","routePath":"/toolset/packages/base/tools/calculator","lang":"","toc":[{"text":"Calculator - (class)","id":"calculator---class","depth":2,"charIndex":3},{"text":"静态方法","id":"静态方法","depth":3,"charIndex":51},{"text":"参数","id":"参数","depth":3,"charIndex":61},{"text":"返回值","id":"返回值","depth":3,"charIndex":140},{"text":"实例方法","id":"实例方法","depth":3,"charIndex":162}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"剪切板","content":"#\n\n\nclipboard - (object)#\n\n剪切板对象, 可以通过该对象的方法操作剪切板\n\n\nclipboard.copy - (function)#\n\n复制文本\n\n参数\n\n必填   参数名    说明        类型       默认值\n是    text   需要复制的文本   string   \n\n返回值: void\n\n\nclipboard.paste - (function)#\n\n读取剪切板中的文本\n\n参数\n\n无\n\n返回值: Promise\n\n\nclipboard.clear - (function)#\n\n清空剪切板\n\n返回值: void\n\n\nclipboard.isCopyable - (attribute)#\n\n是否可复制\n\n返回值: boolean\n\n\nclipboard.isPasteable - (attribute)#\n\n是否可粘贴\n\n返回值: boolean\n\n\nclipboard.isClearable - (attribute)#\n\n是否可清空\n\n返回值: boolean","routePath":"/toolset/packages/base/tools/clipboard","lang":"","toc":[{"text":"clipboard - (object)","id":"clipboard---object","depth":2,"charIndex":3},{"text":"clipboard.copy - (function)","id":"clipboardcopy---function","depth":3,"charIndex":51},{"text":"clipboard.paste - (function)","id":"clipboardpaste---function","depth":3,"charIndex":171},{"text":"clipboard.clear - (function)","id":"clipboardclear---function","depth":3,"charIndex":235},{"text":"clipboard.isCopyable - (attribute)","id":"clipboardiscopyable---attribute","depth":3,"charIndex":285},{"text":"clipboard.isPasteable - (attribute)","id":"clipboardispasteable---attribute","depth":3,"charIndex":344},{"text":"clipboard.isClearable - (attribute)","id":"clipboardisclearable---attribute","depth":3,"charIndex":404}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"cookie","content":"#\n\n\ncookie - (object)#\n\nCookie 管理器, 可以通过该对象的方法操作 Cookie\n\n\ncookie.get - (function)#\n\n获取 cookie\n\n参数\n\n必填   参数    说明           类型       默认值\n*    key   cookie key   string   \n\n返回值: string | null\n\n\ncookie.set - (function)#\n\n设置 cookie\n\n参数\n\n必填   参数        说明             类型               默认值\n*    key       cookie key     string           \n*    value     cookie value   string           \n     options   cookie 配置      ICookieOptions   {}\n\n类型补充\n\nICookieOptions\n\n\n\n返回值: void\n\n\ncookie.remove - (function)#\n\n移除 cookie\n\n参数\n\n必填   参数    说明           类型       默认值\n是    key   cookie key   string   \n\n返回值: void","routePath":"/toolset/packages/base/tools/cookie","lang":"","toc":[{"text":"cookie - (object)","id":"cookie---object","depth":2,"charIndex":3},{"text":"cookie.get - (function)","id":"cookieget---function","depth":3,"charIndex":57},{"text":"cookie.set - (function)","id":"cookieset---function","depth":3,"charIndex":191},{"text":"cookie.remove - (function)","id":"cookieremove---function","depth":3,"charIndex":466}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"池","content":"#\n\n\ncreatePool - (function)#\n\n创建池, 他是一个工厂函数, 返回一个 Pool 实例, 用于管理存储的对象, 池的大小可配置, 默认 5, 并且在按规定使用的情况下每个对象都具有所有权\n\n\n参数#\n\n必填   参数             说明                 类型                默认值\n     initFunction   初始化函数              () => T           ()=>EMPTY\n     size           初始大小               number            5\n     poolId         唯一标识, 不传则直接创建新实例   string | symbol   ‘’\n\n\n返回值#\n\nPool 实例\n\n\n实例类型声明#\n\n\n\n警告\n\nget 返回的 IPoolItem 对象不建议和赋值，可能会影响管理\n\n示例\n\n\n\n\ngetPool - (function)#\n\n\n参数#\n\n必填   参数       说明     类型                默认值\n     poolId   唯一标识   string | symbol   ''\n\n\n返回值#\n\nPool 实例\n\n实例类型声明","routePath":"/toolset/packages/base/tools/createPool","lang":"","toc":[{"text":"createPool - (function)","id":"createpool---function","depth":2,"charIndex":3},{"text":"参数","id":"参数","depth":3,"charIndex":109},{"text":"返回值","id":"返回值","depth":3,"charIndex":363},{"text":"实例类型声明","id":"实例类型声明","depth":3,"charIndex":379},{"text":"getPool - (function)","id":"getpool---function","depth":2,"charIndex":437},{"text":"参数","id":"参数-1","depth":3,"charIndex":461},{"text":"返回值","id":"返回值-1","depth":3,"charIndex":553}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"存储池","content":"#\n\n\ncreateStorePool - (function)#\n\n创建存储池, 返回存储池操作方法, 用于存储数据, 内部通过索引管理, 存储数据时会返回 id, 会自动维护索引, 自动扩容\n\n\n参数#\n\n必填   参数           说明      类型                 默认值\n     controller   存储控制器   IStoreController   DefaultStoreController\n\n类型补充\n\nIStoreController\n\n\n\n\n返回值#\n\nIStorePoolHandle 对象\n\n类型补充\n\nIStorePoolHandle\n\n","routePath":"/toolset/packages/base/tools/createStorePool","lang":"","toc":[{"text":"createStorePool - (function)","id":"createstorepool---function","depth":2,"charIndex":3},{"text":"参数","id":"参数","depth":3,"charIndex":99},{"text":"返回值","id":"返回值","depth":3,"charIndex":249}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"上传管理器","content":"#\n\n\ncreateUploader - (function)#\n\n创建一个上传管理器, 支持并发上传, 可以调整并发的类型, 例如按分片并发, 或者按文件并发, 自动管理上传状态, 并且返回上传进度信息, 内部使用 fetch\n实现文件上传, 可自行传递 headers 和 fetch 的配置, 并且支持通过函数自定义请求体\n\n\n参数#\n\n必填   参数名                      说明            类型                    默认值\n*    options                  uploader 配置   string                \n*    options.url              上传地址          string                \n     options.maxConcurrent    最大并发数         number                3\n     options.concurrentNode   并发节点类型        'file'|'chunk'        'chunk'\n     options.chunkSize        分片大小          number                1024 * 1024\n     options.dataType         数据类型          'FormData'|'binary'   'FormData'\n     options.dataKey          数据 key        string                'file'\n     options.responseType     响应类型          'json'                'json'\n     options.retryCount       重试次数          number                3\n     options.requestMethod    请求方法          'POST'                'POST'\n     options.headers          请求头           Record                {}\n     options.bodyHandler      自定义请求体        TBodyHanderFunc       -\n     options.headersHandler   自定义请求体        THeadersHandler       -\n     options.bodyHandler      自定义请求体        TBodyHanderFunc       -\n     forceCreate              强制创建实例        boolean               false\n\n类型补充\n\n\n\n警告\n\nTBodyHanderFunc 禁止使用闭包 THeadersHanderFunc 禁止使用闭包\n\n\n返回值#\n\nUploadController 实例\n\n实例类型声明#\n\n","routePath":"/toolset/packages/base/tools/createUploader","lang":"","toc":[{"text":"createUploader - (function)","id":"createuploader---function","depth":2,"charIndex":3},{"text":"参数","id":"参数","depth":3,"charIndex":166},{"text":"返回值","id":"返回值","depth":3,"charIndex":1368},{"text":"实例类型声明","id":"实例类型声明","depth":4,"charIndex":1395}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"创建 Worker 函数","content":"#\n\n\ncreateWorkerFunc - (function)#\n\n创建一个在 Worker 中运行的函数\n\n\n参数#\n\n必填   参数名                说明                  类型                     默认值\n*    func               要在 Worker 中运行的函数    (...args:any[])=>any   -\n     importScripts      Worker 运行时需要加载的脚本   string[]               []\n     options            选项                  object                 {}\n     options.reuse      是否复用 Worker         boolean                true\n     options.needPost   是否需要将所有参数打包为数组      boolean                false\n\n警告\n\nneedPost 为 true 时, func 的第一个参数会被替换为 postMessage, 用户自己的参数从形参列表第二项开始\n\npostMessage\n\n运行中返回中间结果\n\n参数\n\n必填   参数名    说明       类型    默认值\n*    data   要发送的数据   any   -\n\n返回值\n\n无\n\n--------------------------------------------------------------------------------\n\n\n返回值#\n\n类型             说明\nIWorkerFuncs   包含了 run dispose on remove clearOn onOnce 方法的对象\n\nrun#\n\n运行函数\n\n参数\n\n必填   参数名       说明                 类型      默认值\n*    ...args   和传入 func 相同的参数列表   any[]   -\n\n返回值\n\n类型        说明\nPromise   func 的返回结果在 Promise 的 then 中接收\n\ndispose#\n\n销毁 Worker\n\n参数\n\n无\n\n返回值\n\n无\n\n警告\n\n下面的方法只有在 needPost 为 true 时才有效\n\non#\n\n监听 postMessage 发送的消息\n\n参数\n\n必填   参数名        说明     类型                    默认值\n*    callback   回调函数   (data: any) => void   -\n\n返回值\n\n无\n\nremove#\n\n移除监听\n\n参数\n\n必填   参数名        说明     类型         默认值\n*    callback   回调函数   TAnyFunc   -\n\n返回值\n\n无\n\nclearOn#\n\n清除所有监听\n\n参数\n\n无\n\n返回值\n\n无\n\nonOnce#\n\n只监听一次\n\n参数\n\n必填   参数名        说明     类型                    默认值\n*    callback   回调函数   (data: any) => void   -\n\n返回值\n\n无","routePath":"/toolset/packages/base/tools/createWorkerFunc","lang":"","toc":[{"text":"createWorkerFunc - (function)","id":"createworkerfunc---function","depth":2,"charIndex":3},{"text":"参数","id":"参数","depth":3,"charIndex":57},{"text":"返回值","id":"返回值","depth":3,"charIndex":740},{"text":"run","id":"run","depth":4,"charIndex":827},{"text":"dispose","id":"dispose","depth":4,"charIndex":994},{"text":"on","id":"on","depth":4,"charIndex":1065},{"text":"remove","id":"remove","depth":4,"charIndex":1201},{"text":"clearOn","id":"clearon","depth":4,"charIndex":1303},{"text":"onOnce","id":"ononce","depth":4,"charIndex":1336}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"事件中心","content":"#\n\n\nEventEmitter - (class)#\n\n事件中心\n\n\n静态方法#\n\n\n\n\n参数#\n\n无\n\n\n返回值#\n\nEventEmitter 实例\n\n\n实例方法#\n\n","routePath":"/toolset/packages/base/tools/eventEmitter","lang":"","toc":[{"text":"EventEmitter - (class)","id":"eventemitter---class","depth":2,"charIndex":3},{"text":"静态方法","id":"静态方法","depth":3,"charIndex":35},{"text":"参数","id":"参数","depth":3,"charIndex":45},{"text":"返回值","id":"返回值","depth":3,"charIndex":54},{"text":"实例方法","id":"实例方法","depth":3,"charIndex":78}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"总览","content":"#\n\n * 计算器\n * 剪贴板\n * Cookie\n * 创建池\n * 创建存储池(推荐使用 创建池 代替)\n * 创建上传器\n * 创建一个在 Worker 中运行的函数\n * 事件管理\n * 日志管理","routePath":"/toolset/packages/base/tools/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"日志管理","content":"#\n\n\nLogger - (class)#\n\n日志管理器\n\n\n静态方法#\n\n\n\n\n参数#\n\n必填   参数名                       说明        类型                           默认值\n     options                   日志配置      object                       \n     options.showModuleIds     展示模块 id   any[]                        []\n     options.showMethods       展示方法      string[]                     ['log', 'info', 'warn', 'error', 'debug']\n     options.ignoreMessage     忽略的消息     string[]|IgnoreMessageFunc   []\n     options.messageTemplate   消息模板      string|MessageTemplateFunc   #[date] #[moduleId]-#[method]:=>#[message]\n     options.controller        日志控制器     Controller                   console\n\n类型扩展\n\nIgnoreMessageFunc\n\n类型声明\n\n\n\nMessageTemplateFunc\n\n类型声明\n\n\n\nController\n\noptions.controller 必须要实现 Controller 接口\n\n类型声明\n\n\n\n\n返回值#\n\nLogger 实例\n\n\n实例方法#\n\n","routePath":"/toolset/packages/base/tools/logger","lang":"","toc":[{"text":"Logger - (class)","id":"logger---class","depth":2,"charIndex":3},{"text":"静态方法","id":"静态方法","depth":3,"charIndex":30},{"text":"参数","id":"参数","depth":3,"charIndex":40},{"text":"返回值","id":"返回值","depth":3,"charIndex":763},{"text":"实例方法","id":"实例方法","depth":3,"charIndex":781}],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"常量","content":"#\n\n\nEMPTY#\n\n空对象\n\n类型声明\n\n\n\n示例\n\n","routePath":"/toolset/packages/base/utils/constant","lang":"","toc":[{"text":"EMPTY","id":"empty","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"数据处理相关方法","content":"#\n\n\ngetArray#\n\n参数归一化为数组\n\n类型声明\n\n\n\n参数\n\n必填   参数      说明   类型    默认值\n     value   数组   any   \n\n返回值: array\n\n示例\n\n\n\n\ngetArraySlice#\n\n获取数组切片\n\n类型声明\n\n\n\n参数\n\n必填   参数      说明     类型       默认值\n*    array   数组     any[]    \n     size    切片大小   number   \n\n返回值: array\n\n示例\n\n\n\n\ndeepClone#\n\n深拷贝\n\n类型声明\n\n\n\n参数\n\n必填   参数    说明    类型   默认值\n     obj   任意值   T    \n\n返回值: T\n\n示例\n\n\n\n\nmerge#\n\n合并对象\n\n类型声明\n\n\n\n参数\n\n必填   参数          说明       类型      默认值\n*    target      合并的目标    T       \n     ...source   合并数据来源   any[]   \n\n返回值: T\n\n示例\n\n\n\n\ncloneMerge#\n\n深拷贝合并对象\n\n类型声明\n\n\n\n参数\n\n必填   参数          说明       类型      默认值\n*    target      合并的目标    T       \n     ...source   合并数据来源   any[]   \n\n返回值: T\n\n示例\n\n\n\n\nasyncReplace#\n\n异步替换\n\n类型声明\n\n\n\n参数\n\n必填   参数         说明     类型                                                    默认值\n*    str        字符串    string                                                -\n*    pattern    正则     string|RegExp                                         -\n*    replacer   替换函数   (match: string, ...args: any[]) => Promise | string   -\n\n返回值: Promise\n\n示例\n\n\n\n\nasyncFilter#\n\n异步过滤\n\n类型声明\n\n\n\n参数\n\n必填   参数          说明     类型                                              默认值\n*    arr         数组     T[]                                             -\n*    predicate   过滤函数   (item: T, index: number) => Promise | boolean   -\n\n返回值: Promise\n\n示例\n\n","routePath":"/toolset/packages/base/utils/dataHandler","lang":"","toc":[{"text":"getArray","id":"getarray","depth":2,"charIndex":3},{"text":"getArraySlice","id":"getarrayslice","depth":2,"charIndex":109},{"text":"deepClone","id":"deepclone","depth":2,"charIndex":258},{"text":"merge","id":"merge","depth":2,"charIndex":352},{"text":"cloneMerge","id":"clonemerge","depth":2,"charIndex":502},{"text":"asyncReplace","id":"asyncreplace","depth":2,"charIndex":660},{"text":"asyncFilter","id":"asyncfilter","depth":2,"charIndex":1033}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"函数处理相关方法","content":"#\n\n\ncacheByReturn#\n\n缓存函数返回值\n\n类型声明\n\n\n\n参数\n\n必填   参数          说明       类型   默认值\n*    cacheLoad   缓存加载函数   F    -\n\n返回值: TCacheByReturnType\n\n示例\n\n\n\n\nmemoize#\n\n缓存函数\n\n类型声明\n\n\n\n参数\n\n必填   参数         说明       类型   默认值\n*    func       缓存加载函数   F    -\n     resolver   缓存解析函数   F    -\n\n返回值: F\n\n示例\n\n\n\n\ncurry#\n\n将普通函数转换为柯里化函数\n\n> 不放类型声明了，太过复杂\n\n参数\n\n必填   参数名   类型         说明        默认值\n*    fn    TAnyFunc   需要转换的函数   -\n\n返回值: 柯里化后的函数\n\n示例\n\n\n\n\ncompose#\n\n组合函数，从右到左执行\n\n> 不放类型声明了，太过复杂\n\n参数\n\n必填   参数名     类型           说明        默认值\n*    funcs   TAnyFunc[]   需要组合的函数   -\n\n返回值: 组合后的函数\n\n示例\n\n\n\n\npipe#\n\n组合函数，从左到右执行\n\n> 不放类型声明了，太过复杂\n\n参数\n\n必填   参数名     类型           说明        默认值\n*    funcs   TAnyFunc[]   需要组合的函数   -\n\n返回值: 组合后的函数\n\n示例\n\n\n\n\ndebounce#\n\n函数防抖\n\n类型声明\n\n\n\n参数\n\n必填   参数名           说明                 类型        默认值\n*    func          要防抖的函数             F         -\n     time          防抖时间，默认为 100ms     number    100\n     immediately   是否立即执行，默认为 false   boolean   false\n\n返回值: (...args: TArgsType) => void\n\n示例\n\n\n\n\nthrottle#\n\n函数节流\n\n类型声明\n\n\n\n参数\n\n必填   参数名           说明                类型        默认值\n*    func          要节流的函数            F         -\n     time          节流时间，默认为 100ms    number    100\n     immediately   是否立即执行，默认为 true   boolean   true\n\n返回值: (...args: TArgsType) => void\n\n示例\n\n\n\n\nchunkTask#\n\n大任务分块执行\n\n类型声明\n\n\n\n参数\n\n必填   参数名    说明   类型   默认值\n*    task   任务   F    -\n\n返回值: (args: T[] | number) => Promise, Promise>>\n\n示例\n\n\n\n\nsleep#\n\n等待指定时间\n\n类型声明\n\n\n\n参数\n\n必填   参数名    说明   类型       默认值\n*    time   时间   number   -\n\n返回值: Promise\n\n示例\n\n\n\n\n\n\nreverseArgs#\n\n反转函数参数\n\n参数\n\n必填   参数名        说明   类型   默认值\n*    callback   回调   F    -\n\n返回值: (...args: ReverseArray>) => ReturnType\n\n示例\n\n","routePath":"/toolset/packages/base/utils/funcHandler","lang":"","toc":[{"text":"cacheByReturn","id":"cachebyreturn","depth":2,"charIndex":3},{"text":"memoize","id":"memoize","depth":2,"charIndex":141},{"text":"curry","id":"curry","depth":2,"charIndex":283},{"text":"compose","id":"compose","depth":2,"charIndex":418},{"text":"pipe","id":"pipe","depth":2,"charIndex":560},{"text":"debounce","id":"debounce","depth":2,"charIndex":699},{"text":"throttle","id":"throttle","depth":2,"charIndex":979},{"text":"chunkTask","id":"chunktask","depth":2,"charIndex":1254},{"text":"sleep","id":"sleep","depth":2,"charIndex":1394},{"text":"reverseArgs","id":"reverseargs","depth":2,"charIndex":1504}],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"数据获取相关方法","content":"#\n\n\ngetRandomString#\n\n获取指定长度的随机字符串\n\n类型声明\n\n\n\n参数\n\n必填   参数    说明      类型       默认值\n     len   字符串长度   number   8\n\n返回值: string\n\n示例\n\n\n\n\ncreateLinkByString#\n\n将传入的字符串转化为 blob 地址\n\n类型声明\n\n\n\n参数\n\n必填   参数         说明     类型       默认值\n*    resource   资源内容   string   -\n\n返回值: string\n\n示例\n\n\n\n\ngenerateCookieInfo#\n\n生成 cookie 信息\n\n类型声明\n\n\n\n参数\n\n必填   参数        说明          类型               默认值\n     options   cookie 配置   ICookieOptions   {}\n\n返回值: string\n\n示例\n\n\n\n\ngenerateClassName#\n\n生成 className\n\n类型声明\n\n\n\n参数\n\n必填   参数     说明   类型                                                      默认值\n*    args   类名   (string|string[]|Record|Record[]|(string|Record)[])[]   -\n\n返回值: string\n\n示例\n\n\n\n\ngetNow#\n\n获取当前时间, 支持 performance API 的浏览器会返回 performance.now, 不支持的浏览器会返回 Date.now\n\n类型声明\n\n\n\n返回值: number\n\n示例\n\n\n\n\ngetOsType#\n\n获取操作系统类型\n\n类型声明\n\n\n\n返回值: \"ios\" | \"android\" | \"openHarmony\" | \"mac\" | \"windows\" | \"linux\" | \"aix\" |\n\"freebsd\" | \"haiku\" | \"openbsd\" | \"sunos\" | \"cygwin\" | \"netbsd\" | \"other\"\n\n示例\n\n\n\n\ngetUserAgent#\n\n获取用户代理\n\n类型声明\n\n\n\n返回值: string\n\n示例\n\n\n\n\ngetDeviceInfo#\n\n获取设备信息\n\n类型声明\n\n\n\n返回值: { appName: string; appVersion: string; screenWidth: number; screenHeight:\nnumber; devicePixelRatio: number; platform: string; userAgent: string; }\n\n示例\n\n\n\n\nsafeGetGlobal#\n\n安全获取全局变量\n\n类型声明\n\n\n\n返回值: any\n\n示例\n\n\n\n\ngetType#\n\n获取值类型\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: string\n\n示例\n\n","routePath":"/toolset/packages/base/utils/getData","lang":"","toc":[{"text":"getRandomString","id":"getrandomstring","depth":2,"charIndex":3},{"text":"createLinkByString","id":"createlinkbystring","depth":2,"charIndex":130},{"text":"generateCookieInfo","id":"generatecookieinfo","depth":2,"charIndex":274},{"text":"generateClassName","id":"generateclassname","depth":2,"charIndex":437},{"text":"getNow","id":"getnow","depth":2,"charIndex":656},{"text":"getOsType","id":"getostype","depth":2,"charIndex":766},{"text":"getUserAgent","id":"getuseragent","depth":2,"charIndex":957},{"text":"getDeviceInfo","id":"getdeviceinfo","depth":2,"charIndex":1008},{"text":"safeGetGlobal","id":"safegetglobal","depth":2,"charIndex":1200},{"text":"getType","id":"gettype","depth":2,"charIndex":1251}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"总览","content":"#\n\n * 常量\n * 函数处理相关方法\n * 数据处理相关方法\n * 数据获取相关方法\n * 校验相关方法\n * 客户端判断相关方法","routePath":"/toolset/packages/base/utils/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"客户端判断相关方法","content":"#\n\n * isNode (判断是否为 node 环境)\n * isWeb (判断是否为 web 环境)\n * isIOS (判断是否为 iOS 环境)\n * isAndroid (判断是否为 Android 环境)\n * isChrome (判断是否为 Chrome 环境)\n * isFirefox (判断是否为 Firefox 环境)\n * isSafari (判断是否为 Safari 环境)\n * isNewEdge (判断是否 新版 Edge 环境)\n * isOldEdge (判断是否 旧版 Edge 环境)\n * isEdge (判断是否为 Edge 环境)\n * isWeex (判断是否为 Weex 环境)\n * isKraken (判断是否为 Kraken 环境)\n * isQuickApp (判断是否为 QuickApp 环境)\n * isTBWeb (判断是否为 淘宝 web 环境)\n * isLTWeb (判断是否为 淘特 web 环境)\n * isTbLive (判断是否为 淘宝直播环境)\n * isTbWebEnv (判断是否为 淘宝 web 环境)\n * isWechatWeb (判断是否为 微信 web 环境)\n * isAliPayWeb (判断是否为 支付宝 web 环境)\n * isWebInDingding (判断是否为 钉钉 web 环境)\n * isTuan (判断是否为 淘宝环境)\n * isLST (判断是否为 零售通环境)\n * isLXB (判断是否为 零销宝环境)\n * isAliAppWeb (判断是否为 阿里应用 web 环境)\n * isMiniApp (判断是否为 小程序环境)\n * isAliMiniApp (判断是否为 阿里小程序环境)\n * isDingdingMiniapp (判断是否为 钉钉小程序环境)\n * isTaobaoMiniapp (判断是否为 淘宝小程序环境)\n * isAlipayMiniapp (判断是否为 支付宝小程序环境)\n * isTBMiniapp (判断是否为 淘宝小程序环境)\n * isLTMiniapp (判断是否为 淘特小程序环境)\n * isMMCMiniapp (判断是否为 猫超小程序环境)\n * isXiNiaoapp (判断是否为 西南小程序环境)\n * isCaiNiaoApp (判断是否为 菜鸟小程序环境)\n * isAlipayApp (判断是否为 支付宝小程序环境)\n * isByteDanceMicroApp (判断是否为 字节小程序环境)\n * isBaiduSmartProgram (判断是否为 百度小程序环境)\n * isKuaiShouMiniProgram (判断是否为 快手小程序环境)\n * isWeChatMiniProgram (判断是否为 微信小程序环境)\n * isAliMiniappPlatform (判断是否为 支付宝小程序平台环境)\n * isTBNode (判断是否为 淘宝 node 环境)\n * isLTNode (判断是否为 淘特 node 环境)\n * isWechatNode (判断是否为 微信 node 环境)\n * isTB (判断是否为 淘宝环境)\n * isLT (判断是否为 淘特环境)\n * isAliPay (判断是否为 支付宝环境)\n * isTmall (判断是否为 天猫环境)\n * isAliApp (判断是否为 阿里应用环境)\n * isWechat (判断是否为 微信环境)\n * isCaiNiaoBusiness (判断是否为 菜鸟商家环境)\n * isCaiNiao (判断是否为 菜鸟环境)\n * isAliUa (判断是否为 阿里环境)\n * isHmApp (判断是否为 盒马环境)\n * isYouKu (判断是否为 优酷环境)\n * isAlipayMiniWeb (判断是否为 支付宝小程序 web 环境)\n * isLTMiniWeb (判断是否为 淘特小程序 web 环境)\n * isLBMiniWeb (判断是否为 零销宝小程序 web 环境)\n * isTBMiniWeb (判断是否为 淘宝小程序 web 环境)\n * isDingTalk (判断是否为 钉钉环境)\n * isTuanWebview (判断是否为 团长小程序 webview 嵌套的h5)\n * isWechatMiniWeb (判断是否为 微信小程序 web 环境)\n * isWechatH5 (判断是否为 微信 h5 环境)\n * isWebInMiniApp (判断是否为 小程序 web 环境)\n * isAliWebInMiniApp (判断是否为 阿里小程序 web 环境)\n * isAliAppMiniApp (判断是否为 阿里小程序环境)\n * isOpenHarmony (判断是否为 鸿蒙操作系统)\n * isIPhoneX (判断是否为 iPhoneX 操作系统)\n * isIPhoneXSMax (判断是否为 iPhoneXSMax 操作系统)\n * isIPhoneXR (判断是否为 iPhoneXR 操作系统)\n * isIPhone14PM (判断是否为 iPhone14PM 操作系统)\n * isIOSNotchScreen (判断是否为 有刘海屏)","routePath":"/toolset/packages/base/utils/ua","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"校验相关方法","content":"#\n\n\nisNull#\n\n判断是否为 null\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisNaN#\n\n判断是否为 NaN\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisNumber#\n\n判断是否为数字\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisPromise#\n\n判断是否为 Promise\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisEmpty#\n\n判断是否为空\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisFile#\n\n判断是否为文件\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisBlob#\n\n判断是否为 Blob\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisHttpUrlString#\n\n判断是否为 http 链接字符串\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisBlobUrlString#\n\n判断是否为 blob 链接字符串\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisDataUrlString#\n\n判断是否为 data 链接字符串\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisUrl#\n\n判断是否为 url\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisAsyncFunc#\n\n判断是否为异步函数\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisUndef#\n\n判断是否为 undefined\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisString#\n\n判断是否为字符串\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisHttpsUrlString#\n\n判断是否为 https 链接字符串\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean\n\n示例\n\n\n\n\nisTrue#\n\n判断是否为 true\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean 示例\n\n\n\n\nisFalse#\n\n判断是否为 false\n\n类型声明\n\n\n\n参数\n\n必填   参数名     类型    描述      默认值\n*    value   any   待判断的值   -\n\n返回值: boolean 示例\n\n\n\n\nisInIframe#\n\n判断是否在 iframe 中\n\n类型声明\n\n\n\n返回值: boolean\n\n示例\n\n","routePath":"/toolset/packages/base/utils/verify","lang":"","toc":[{"text":"isNull","id":"isnull","depth":2,"charIndex":3},{"text":"isNaN","id":"isnan","depth":2,"charIndex":118},{"text":"isNumber","id":"isnumber","depth":2,"charIndex":231},{"text":"isPromise","id":"ispromise","depth":2,"charIndex":345},{"text":"isEmpty","id":"isempty","depth":2,"charIndex":466},{"text":"isFile","id":"isfile","depth":2,"charIndex":578},{"text":"isBlob","id":"isblob","depth":2,"charIndex":690},{"text":"isHttpUrlString","id":"ishttpurlstring","depth":2,"charIndex":805},{"text":"isBlobUrlString","id":"isbloburlstring","depth":2,"charIndex":935},{"text":"isDataUrlString","id":"isdataurlstring","depth":2,"charIndex":1065},{"text":"isUrl","id":"isurl","depth":2,"charIndex":1195},{"text":"isAsyncFunc","id":"isasyncfunc","depth":2,"charIndex":1308},{"text":"isUndef","id":"isundef","depth":2,"charIndex":1427},{"text":"isString","id":"isstring","depth":2,"charIndex":1548},{"text":"isHttpsUrlString","id":"ishttpsurlstring","depth":2,"charIndex":1663},{"text":"isTrue","id":"istrue","depth":2,"charIndex":1795},{"text":"isFalse","id":"isfalse","depth":2,"charIndex":1909},{"text":"isInIframe","id":"isiniframe","depth":2,"charIndex":2025}],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"目录","content":"#","routePath":"/toolset/packages/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"@cmtlyt/json-schema","content":"#\n\n类型补充\n\n\n\n\njsonSchemaGenerator#\n\njson schema 生成器\n\n类型声明\n\n\n\n参数\n\n必填   参数     说明   类型        默认值\n*    data   数据   TObject   \n\n返回值: Schema\n\n示例\n\n\n\n\nverifyBySchema#\n\n验证数据是否符合 schema\n\n类型声明\n\n\n\n参数\n\n必填   参数       说明       类型        默认值\n*    schema   schema   Schema    \n*    data     数据       TObject   \n\n返回值: Promise<[boolean, { path: string; message: string }[] | null]>\n\n示例\n\n\n\n\nmockFromSchema#\n\n根据 schema 生成 mock 数据\n\n类型声明\n\n\n\n参数\n\n必填   参数           说明       类型        默认值\n*    schema       schema   Schema    \n     handlerMap   类型处理器    Partial   \n\n返回值: any\n\n示例\n\n","routePath":"/toolset/packages/jsonSchema/","lang":"","toc":[{"text":"jsonSchemaGenerator","id":"jsonschemagenerator","depth":2,"charIndex":11},{"text":"verifyBySchema","id":"verifybyschema","depth":2,"charIndex":142},{"text":"mockFromSchema","id":"mockfromschema","depth":2,"charIndex":370}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"BFF","content":"#\n\n\n简介#\n\nBFF (Backend for Frontend, 服务于前端的后端), 是一种架构模式, 旨在优化和提升前端应用与后端服务间的交互效率和用户体验. 现代\nWeb 和移动应用开发中, BFF 层扮演者桥梁的角色, 主要关注点在于如何更好的服务前端需求, 特别是针对不同平台和设备的定制化需求\n\n\n核心内容#\n\n\n用户体验适配层#\n\nBFF 层作为后端与前端的中间层, 能够针对不同前端应用 (如 Web, 移动 App, 桌面应用等) 的特点和需求, 提供定制化的 API 相应. 这意味着\nBFF 可以根据前端具体要求对数据进行裁剪、格式化和聚合, 从而减少前端处理数据的复杂度, 提升加载速度和用户体验\n\n\nAPI 聚合层#\n\n在一个微服务架构中, 一个前端应用可能需要从多个够短服务获取数据. BFF 层可以将这些请求聚合起来, 向前端提供一个统一的接口,\n减少前端与多个后端服务直接交互的复杂性和网络开销. 这有助于简化前端逻辑, 提高响应速度和应用的可维护性\n\n\n快速迭代支持#\n\nBFF 层的设计使得前端的迭代可以更加灵活快速, 因为它允许独立于后端服务的变更. 当前端需求快速变化时, BFF 层可以快速调整 API 逻辑,\n无需改动地岑哥服务, 从而加速产品迭代周期\n\n\n安全与认证#\n\nBFF 层开负责处理安全相关的逻辑, 如身份验证、授权和敏感数据的保护. 他可以作为一个额外的安全屏障, 确保前端请求的数据符合安全策略,\n同时也减轻了前端应用的安全负担\n\n\n技术栈选择灵活性#\n\nBFF 层可以使用最适合前端需求的技术来实现, 比如 NodeJS 搭配 Express 或 Koa 框架, 或者使用 Spring Boot 等.\n这种灵活性使得开发者能够更高效地开发和维护 BFF 服务\n\n\n解耦与扩展#\n\n通过 BFF 层的引入, 前后端的耦合度歼敌, 后端服务可以专注于核心业务逻辑, 而 BFF 则负责适应前端的多样化需求, 提高了系统的整体扩展性和灵活性\n\n\n实现注意事项#\n\n避免重复实现: 合理规划 BFF 层以减少重复代码, 确保不同前端应用间可以共享逻辑 监控与日志: 由于 BFF 直接面向用户请求,\n因此其性能监控、日志记录和错误处理机制至关重要 缓存策略: 合理利用缓存可以显著提升相应速度, 特别是在数据聚合的高频查询的场景下\n\n综上所属, BFF 层的设计和实现是为了更好的适配前端应用的多样性, 提升用户体验, 同时保持后端服务的稳定性和可维护性","routePath":"/toolset/wiki/BFF","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"核心内容","id":"核心内容","depth":2,"charIndex":157},{"text":"用户体验适配层","id":"用户体验适配层","depth":3,"charIndex":165},{"text":"API 聚合层","id":"api-聚合层","depth":3,"charIndex":315},{"text":"快速迭代支持","id":"快速迭代支持","depth":3,"charIndex":446},{"text":"安全与认证","id":"安全与认证","depth":3,"charIndex":553},{"text":"技术栈选择灵活性","id":"技术栈选择灵活性","depth":3,"charIndex":649},{"text":"解耦与扩展","id":"解耦与扩展","depth":3,"charIndex":766},{"text":"实现注意事项","id":"实现注意事项","depth":2,"charIndex":854}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"CI/CD","content":"#\n\n\n简介#\n\nCI/CD 代表持续集成 (Continuous Integration, CI)、持续交付 (Continuous Delivery, CD) 和持续部署\n(Continuous Deployment, CD), 是现代软件开发中采用的一套实践和原则, 旨在频繁、快速且可靠的交付软件变更.\n\n\n持续集成 (Continuous Integration, CI)#\n\n持续集成强调开发人员经常性地 (通常是每天多次) 将代码变更合并到共享的主线 (如 master 或 main 分支) 上. 每次代码合并后,\n自动化的构建和测试流程都会被触发, 以验证新代码是否能成功构建并且不破坏现有功能. 这包括单元测试、集成测试等, 确保代码质量并及时发现和修复问题.\n\n\n持续交付 (Continuous Delivery, CD)#\n\n持续交付建立在持续集成的基础上, 目标是使软件始终处于可随时部署到生产环境的状态. 这意味着一旦代码通过所有阶段的自动化测试, 就可以立即发不到生产环境,\n但是否实际部署通常是一个手动触发的决策. 持续交付强调的是快速、高质量的软件准备过程, 以便业务决定最佳的发布时间.\n\n\n持续部署 (Continuous Deployment, CD)#\n\n持续部署则更新一步, 他自动将所有通过测试的代码变更部署到生产环境中, 无需人工干预. 这就意味着每次代码推动, 只要通过了自动化测试套件,\n就会自动部署到用户手中. 这种做法要求有高度成熟的自动化测试和即时回滚机制, 以确保即使有错误发生也能迅速恢复.\n\n\nCI/CD 的核心价值#\n\n * 加速反馈循环: 快速发现和修复问题, 减少软件发布周期\n * 提高软件质量: 自动化测试确保了代码变更的可靠性\n * 减少人为错误: 自动化流程降低了手动操作出错的可能性\n * 提升团队协作: 促进开发、测试和运维之间的紧密合作\n * 增强发布信心: 确保软件随时可以安全、稳定地部署\n\nCI/CD 流程通常依赖于一套工具链, 如 Jenkins、GitLab CI/CD、Travis CI、CircelCI、Github Actions 等,\n来自动化构建、测试和部署任务.","routePath":"/toolset/wiki/CI_CD","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"持续集成 (Continuous Integration, CI)","id":"持续集成-continuous-integration-ci","depth":2,"charIndex":157},{"text":"持续交付 (Continuous Delivery, CD)","id":"持续交付-continuous-delivery-cd","depth":2,"charIndex":342},{"text":"持续部署 (Continuous Deployment, CD)","id":"持续部署-continuous-deployment-cd","depth":2,"charIndex":514},{"text":"CI/CD 的核心价值","id":"cicd-的核心价值","depth":2,"charIndex":679}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"构造方法","content":"#\n\n\n简介#\n\n在 JavaScript 中, class 是一种更简洁的、更面向对象的语法来创建对象和处理继承的方式. constructor 是类的一个特殊方法,\n用于初始化创建类的实例. 当使用 new 关键字创建类的实例时, constructor 方法会自动被调用进行实例的初始化.\n\n\n示例#\n\n\n\n在这个示例中, 我们定义了一个 Person 类, 并在其 constructor 方法中初始化了 name 属性. 然后我们使用 new 关键字创建了一个\nPerson 类的实例, 并将其赋值给 person. 最后, 我们使用 person.name 来访问 name 属性的值.\n\n在这其中我们没有手动的调用 constructor 方法, 但他却自动调用了, 这就是因为我们使用了 new 关键字, 所以自动调用了 constructor\n方法.\n\n\n那些你可能不知道的事#\n\n根据 TC39 的描述, constructor 方法其实可以返回 3 种结果\n\n * EMPTY\n * ClassElement\n * ClassElementList\n\nEMPTY\n\nEMPTY 就是什么都不返回, 在这种情况下会自动返回当前 class 的实例, 例如示例中的 Person 类一样, 他就是直接返回了 Person\n类本身的实例\n\nClassElement\n\nClassElement 从字面上理解就是一个 class 元素, 如果返回 class 元素的话, 那这个 constructor 不会直接返回这个新的\nclass 元素, 而不是 new 的那个类的实例\n\n从字面上来看的话他应该需要一个 class 元素, 但是实际上, 只要不是基本数据类型, 都可以替换类本身的实例\n\n如果返回的是一个基本数据类型的话那么和返回 EMPTY 是没有本质区别的\n\n示例\n\n\n\nClassElementList\n\nClassElementList 就是一个 class 元素列表, 如果返回 class 元素列表的话, 那么这个 constructor 就会返回一个新的\nclass 元素列表, 而不是 new 的那个类的实例\n\n同样, 从字面上来看的话他是一个 class 元素列表, 但是实际上, 他可以返回任何类型的数组, 包括 [1], [''], [true] 等,\n他并不会深度判断数组中元素的实际类型\n\nClassElement 的返回值为一个数组那就是 ClassElementList 了, 只是底层会被识别为 ClassElementList 罢了\n\n对于我们使用者来说的话, ClassElementList 和 ClassElement 没啥区别\n\n\n补充#\n\n当然不仅是 class 的 constructor 满足这个返回规则, function 类也满足这个返回值的规则\n\n","routePath":"/toolset/wiki/ConstructorMethod","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"示例","id":"示例","depth":3,"charIndex":149},{"text":"那些你可能不知道的事","id":"那些你可能不知道的事","depth":2,"charIndex":386},{"text":"补充","id":"补充","depth":2,"charIndex":1147}],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"依赖倒置原则","content":"#\n\n\n简介#\n\n依赖倒置原则 (Dependency Inversion Principle, DIP) 是面向对象设计的五大基本原则之一, 由 Robert C.\nMartin 在 1996 年首次提出. 该原则是 SOLID 原则中的 D 原则, 强调了软件设计中依赖关系的管理和组织方式,\n旨在提高软件的灵活性、可扩展性和和测试性.\n\n依赖倒置原则主要包括两个核心要点:\n\n 1. 高层模块不应该依赖于低层模块, 两者都应该依赖于抽象. 在传统的软件设计中, 高层模块 (如业务逻辑层) 往往直接依赖于底层模块 (如数据访问层).\n    依赖倒置原则要求我们颠倒这种依赖关系, 即不是高层直接依赖低层, 而是双方都依赖于一个抽象的接口或者抽象类. 这样做的好处是, 当低层模块发生变化时,\n    不会直接影响到高层模块, 降低了模块间的耦合度\n 2. 抽象不应该依赖于细节, 细节应该依赖于抽象. 这一点是对第一点的进一步阐述, 强调在设计中, 我们应该从具体的实现中抽离出接口或抽象类,\n    让具体的实现类去实现这些抽象定义. 这样一来, 具体实现的变更不会影响到使用这些抽象的代码, 保证了系统的灵活性和可扩展性\n\n依赖倒置原则的实现通常需要借助一下设计模式和技术:\n\n * 接口编程: 定义清晰的接口来规范模块间交互, 而不是直接编程到具体类上\n * 依赖注入 (DI): 一种实现控制反转 (IoC, Inversion of Control) 的方式, 通过外部容器或框架来注入依赖对象,\n   而不是在类内部创建依赖对象, 从而实现依赖关系的解耦\n * 抽象类: 当具体实现由共性操作时, 可以使用抽象类来提供默认行为, 并要求子类遵循一定的接口规范\n\n遵循依赖倒置原则可以帮助我们构建更加灵活、可维护的系统, 是的系统更容易应对变化, 也便于进行单元测试.","routePath":"/toolset/wiki/SOLID/DIP","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"接口隔离原则","content":"#\n\n\n简介#\n\n接口隔离原则 (Interface Segregation Principle, ISP) 是 SOLID 设计原则之一,\n他强调客户端不应该依赖他不需要的接口. 这一原则指导我们设计细粒度的接口, 以减少耦合并提高系统的灵活性和可维护性.\n\n原则说明\n\n * 核心思想: 每个接口应该专注于提供一组相关的行为, 客户端仅需指导他所关心的方法, 而无需了解他不使用的功能. 这样可以减少不必要的依赖,\n   使得系统更加解耦\n * 避免胖接口: 胖接口 (包含大量不相关方法的接口) 会迫使实现它的类包含很多可能不需要的方法, 这违反了接口隔离原则.\n   应该将这样的大接口拆分为多个小而具体的接口\n * 客户端定制接口: 为不同的客户端提供定制化的接口, 每个客户端仅使用与之直接相关的接口, 这样可以确保接口的纯粹性和客户端的简洁性\n * 提高灵活性和可测试性: 细粒度的接口使得替换和 mock (在测试中模拟对象) 变得更加容易, 从而提高了系统的测试性和可扩展性\n\n实现方法\n\n 1. 模块化接口设计: 根据功能将接口拆分成多个小模块, 每个模块代表一类相关操作\n 2. 使用多重继承或接口继承 (如果语言支持): 允许类实现多个小接口, 而不是单一的大接口\n 3. 基于角色设计接口: 考虑类在系统中的角色和他需要提供的服务, 据此来定义接口\n 4. 持续审查和重构: 随着系统的发展, 定期检查接口的使用情况, 即时拆分过大的接口, 确保接口职责清晰\n\n遵循接口隔离原则可以帮助我们构建更加灵活、可扩展的系统, 特别是在大型项目或团队协作中, 他能够显著降低因接口滥用导致的负责性和混乱.","routePath":"/toolset/wiki/SOLID/ISP","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"里氏替换原则","content":"#\n\n\n简介#\n\n里氏替换原则 (Liskov Substitution Principle, LSP) 是面向对象编程中的一个基本原则, 由芭芭拉·利斯科夫 (Barbara\nLiskov) 在 1987 年首次提出. 这一原则表述了一个非常重要的思想: 在软件中, 子类应当能够替换他们的基类 (父类) 而不影响程序的正确性.\n换句话说, 任何可以使用基类的地方, 都应该可以使用子类而不引发错误或导致程序行为变化.\n\n具体来说, 里氏替换原则强调了一下几点\n\n 1. 行为一致性: 子类应当保持父类的行为约定, 这意味着子类不应改变父类已经承诺的接口行为\n 2. 扩展而非修改: 子类可以扩展父类的功能, 但不得修改父类已有的功能, 以确保使用父类的客户端代码不会因为替换为子类而受到影响\n 3. 合约一致性: 子类应当遵守与基类相同的前置条件和后置条件, 以及不变量, 这是保证替换安全性的关键\n\n遵循里氏替换原则的好处:\n\n * 提高代码的可维护性和可扩展性: 允许我们在不修改现有代码的情况下添加新功能\n * 增强软件的稳定性: 减少因类之间不恰当的继承关系而导致的错误\n * 支持开闭原则: 帮助实现对修改关闭, 对扩展开放的设计目标, 从而更容易应对需求变化\n\n简而言之, 里氏替换原则是知道我们如何正确设计继承关系的原则, 确保软件设计的灵活性和可靠性","routePath":"/toolset/wiki/SOLID/LSP","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"开闭原则","content":"#\n\n\n简介#\n\n开闭原则 (Open-Closed Principle, OCP) 是面向对象编程和软件工程中的一项更重要设计原则, 由 Bertrand Meyer 1898\n年在他的著作《面向对象软件构造》中提出. 这一原则指出软件实体 (如类、模块和函数等) 应该对扩展开放 (Open for Extension), 对修改关闭\n(Closed for Modification). 换句话说, 应该能够在不改动现有代码的基础上扩展功能, 当需要改变系统的行为时,\n优先考虑通过添加新代码来实现, 而不是修改已有的、经过测试并验证正确的代码.\n\n开闭原则的核心思想在于提高软件的可维护性和可扩展性,同时歼敌模块之间的耦合度. 他鼓励设计者在编写程序时, 规划好未来可能的变化点,\n并提供抽象的接口或者抽象类来隔离变化, 使得当需求变化时, 可以向系统中添加新的实现, 而不需要修改现有的、已经工作良好的代码.\n\n要实现开闭原则, 通常需要依赖于以下设计技术:\n\n * 抽象化: 定义清晰的抽象接口或抽象类, 让具体实现通过集成货实现接口的方式来变化\n * 多态性: 利用多态机制, 让程序可以调用抽象接口定义的方法, 而无需知道具体的实现类是什么\n * 依赖倒置: 高层模块不依赖于底层模块的具体实现, 两者都应该依赖于抽象, 抽象不应该依赖于细节, 细节应该依赖于抽象\n\n遵循开闭原则可以使如那件更易于维护和升级, 减少因修改既有代码带来的风险, 同时也促进了代码的重用.","routePath":"/toolset/wiki/SOLID/OCP","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"单一职责原则","content":"#\n\n\n简介#\n\n单一职责原则 (Single Responsibility Principle, SRP) 是面向对象设计中最基本的原则之一, 由罗伯特·C·马丁\n(Robert C. Martin) 提出. 这一原则核心思想是: 一个类或者模块应该有且只有一个明确的责任, 并且这个责任应该由这个类完全封装起来.\n换句话说, 一个类应该专注于做好一件事情, 而不应该试图同时处理多件事情.\n\n原则说明\n\n * 定义清晰的职责: 每个类或模块应该专注于执行特定的任务或承担特定的责任. 这样可以确保代码的逻辑清晰, 易于理解和维护\n * 避免职责扩展: 随着项目的发展, 很容易倾向于在一个类中添加更多的功能, 这会导致类变得庞大且难以管理, 违反了单一职责原则\n * 促进代码重用: 当类的职责单一时, 他们更可能在不同的场景下呗重用, 因为他们不会携带不必要的依赖或行为\n * 简化变更影响: 当需要修改或扩展功能时, 由于职责分离, 会影响相关的类, 减少了修改带来的潜在错误风险\n\n实现方式\n\n 1. 分析类的功能: 在设计阶段, 仔细分析所需完成的任务, 将这些任务分解成独立的职责\n 2. 创建小而专的类: 为每个职责创建一个独立的类, 每个类都应有清晰的职责边界\n 3. 利用接口和抽象类: 通过定义接口或抽象类来规范类之间的交互, 使得具体实现可以在不改变接口定义的情况下变化, 进一步促进单一职责的实现\n 4. 持续重构: 随着需求的变化, 定期审查代码, 发现并纠正那些开始承担过多职责的类\n\n遵循单一职责原则, 虽然可能会导致系统中的类数量增多, 但这换来的是更高的可读性、可维护性和可测试性, 长期来看, 对软件项目的健康和可持续发展是非常有益的.","routePath":"/toolset/wiki/SOLID/SRP","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":38,"title":"简介","content":"#\n\nSOLID 是面向对象编程和设计领域中的五个设计原则的首字母缩写, 他们是导致软件开发人员设计更高质量、更易维护代码的重要原则. SOLID 原则由\nRobert C. Martin (也被称为 Uncle Bob) 汇总提出, 每个字母分别代表一下原则:\n\n 1. 单一职责原则 (Single Responsibility Principle, SRP)\n 2. 开放封闭原则 (Open-Closed Priniciple, OCP)\n 3. 里氏替换原则 (Liskov Substitution Principle, LSP)\n 4. 接口隔离原则 (Interface Segregation Principle, ISP)\n 5. 依赖倒置原则 (Dependency Inversion Principle, DIP)\n\n遵循 SOLID 原则可以显著提升软件的结构质量, 使其更加强壮、可维护和可扩展. 这些原则虽各自独立, 但相互之间也有联系,\n共同构成了面向对象设计的坚实基础.","routePath":"/toolset/wiki/SOLID/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"简介","content":"#\n\nTurbo 是下一代前端开发工具链, 使用 Rust 编写, 他由 3 个主要部分组成\n\n * Trubopack: 继承自 Webpack 的增量打包机\n * Turborepo: 增量构建系统\n * Turbo engine: 底层的增量计算和缓存引擎\n\n什么叫增量构建\n\n增量构建是一种构建方法, 他的主要目的是提高开发效率和节约资源. 在软件开发尤其是大型项目中, 每次微小的修改如果都触发整个项目的重新构建,\n将会非常耗时而且没有必要. 增量构建技术就可以让我们只重新构建那些自上次构建依赖发生改变的代码或资源部分, 而跳过没有变化的部分 (或许就是你这次修改的文件).\n\n增量构建的核心特点包括:\n\n 1. 节省时间: 由于只重新编译或处理变更的文件, 大大减少了构建所需要的时间\n 2. 提升开发效率: 开发者可以快速的看到他们的更改效果, 加快了调试和迭代的速度\n 3. 资源优化: 减少了 CPU、内存等资源的消耗\n 4. 持续集成/持续部署 (CI/CD): 在自动化流水线中, 增量构建能够使快速部署成为可能, 加快软件交付流程\n\n应用场景示例:\n\nWeb 开发中的 Webpack: 在使用 Webpack 作为模块打包工具时, 配合 webpack-dev-server, 他能够监视文件变化,\n仅重新打包发生变化的模块, 实现快速的热更新 Android Studio 与 Gradle: Android 应用开发中, Gradle\n构建系统利用其内置的增量构建能力、仅重新编译有变动的源代码文件或依赖, 而不是整个目录 大数据处理工具如 Apache Kylin: 在大数据分析领域,\n增量构建用于避免对整个数据集的全量计算, 而是仅处理新到达的数据段, 适用于频繁更新的大数据立方体 (Cube)\n\n总之, 增量构建的核心价值在于通过智能化的识别并处理真正需要重新构建的部分, 从而达到高效、快速的构建目的.\n\n\n补充#\n\nTurborepo 是一个针对 JavaScript 和 TypeScript 代码库进行优化的智能构建系统.\n\n他可以使用缓存来增强本地设置并加快项目持续集成 (CI) 的速度.\n\nTurborepo 一开始的设计就是增量采用的, 你可以随时把他加入到你的项目中, 而不是必须在创建项目的时候就加入.\n\nTurborepo 的 monorepo 可以和 npm、pnpm、yarn 等包管理工具配合使用, 如果觉得你现在的 monorepo 拖慢了你的速度,\n那或许你就可以开始使用 Turborepo 了.","routePath":"/toolset/wiki/Turbo/","lang":"","toc":[{"text":"补充","id":"补充","depth":2,"charIndex":825}],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"WebRTC","content":"#\n\n\n简介#\n\nWebRTC (Web Real-Time Communication) 是一种开放的实时通信技术, 它允许网页和移动应用通过简单的 API\n实现浏览器之间点对点的音频、视频和数据共享, 而无需安装浏览器插件或额外的软件. WebRTC 的核心组件和技术主要包括以下几点:\n\n * Peer-to-Peer(P2P) 链接: WebRTC 利用 RTCPeerConnection API 建立浏览器之间的直接连接, 允许数据\n   (如音频、视频流) 在用户间直接传输, 减少了服务器中转的需求, 从而降低了延迟并提高了效率\n * 媒体捕获和处理: 通过 getuserMedia API, WebRTC 能够访问用户的摄像头和麦克风, 捕获音频和视频数据. MediaStream\n   API 则用于处理这些媒体流\n * 音视频编解码: 为了实现实时通信, WebRTC 使用高效的音频和视频编解码器来压缩和解压缩数据流, 如 VP8、VP9 视频编解码器和 Opus\n   音频编解码器, 以适应网络带宽限制并保证通信质量\n * 信令机制: 虽然 WebRTC 本身不指定信令协议, 但需要一个外部信令服务 (如 WebSocket、 XMPP 或其他自定义解决方案)\n   来协调两端的链接过程, 交换必要的会话信息 (如 SDP 描述符), 建立和维护连接\n * 数据通道: 处理音视频通信外, WebRTC 还提供了 DataChannel API, 允许两个浏览器之间建立低延迟、高吞吐量的数据传输通道,\n   适用于游戏、文件共享、协作编辑等多种应用场景\n\nWebRTC 被设计为跨平台的, 支持多种操作系统和浏览器, 包括 Chrome、Firefox、Safari(有限度支持)、Edge 等,\n广泛应用于在线教育、远程会议、即时通讯、游戏、医疗健康等多个领域. 由于其开放性和强大的功能集, WebRTC 已经成为实时互联网通信领域的一个重要标准\n\n\n接口#\n\n * RTCPeerConnection: 表示本地计算机与远程对等方之间的 WebRTC 连接. 它用于处理两个对等方之间的数据流式传输\n * RTCDataChannel: 表示连接的两个对等方之间的双向数据通道\n * RTCDataChannelEvent (英语): 表示在将 RTCDataChannel 附加到 RTCPeerConnection 时发生的事件.\n   使用此接口发送的唯一事件是 datachannel\n * RTCSessionDescription: 表示会话的参数. 每个 RTCSessionDescription 包括一个描述\n   type，指示其描述的提议/应答协商过程的哪一部分，以及会话的 SDP 描述符\n * RTCStatsReport: 提供有关连接或连接上的个别轨道的统计信息的详细信息；可以通过调用 RTCPeerConnection.getStats()\n   来获取报告\n * RTCIceCandidate: 表示用于建立 RTCPeerConnection 的候选交互式连接建立（ICE）服务器\n * RTCIceTransport (英语): 表示有关 ICE 传输的信息\n * RTCPeerConnectionIceEvent: 表示与目标 ICE 候选项相关的事件，通常是 RTCPeerConnection.\n   此类型仅有一个事件：icecandidate\n * RTCRtpSender (英语): 管理在 RTCPeerConnection 上的 MediaStreamTrack 的数据编码和传输\n * RTCRtpReceiver (英语): 管理在 RTCPeerConnection 上的 MediaStreamTrack 的数据接收和解码\n * RTCTrackEvent (英语): 用于表示 track 事件的接口，该事件指示已将 RTCRtpReceiver 对象添加到\n   RTCPeerConnection 对象，表示已创建并添加了新的传入 MediaStreamTrack 至 RTCPeerConnection\n * RTCSctpTransport (英语): 提供描述流控制传输协议（SCTP）传输的信息，并提供一种访问底层的用于所有\n   RTCPeerConnection 的数据通道发送和接收的 SCTP 包的数据报传输层安全（DTLS）传输的方式\n\n\n事件#\n\n * bufferedamountlow: 表示数据通道当前缓冲的数据量（由其 bufferedAmount\n   属性指示）已经减少到或低于通道的最小缓冲数据大小（由 bufferedAmountLowThreshold 指定）\n * close: 数据通道已完成关闭过程，现在处于 closed 状态. 此时，其底层数据传输完全关闭. 你可以通过观察 closing\n   事件来在关闭完成之前得到通知\n * closing: RTCDataChannel 已转换为 closing 状态，表示它将很快关闭. 你可以通过观察 close 事件来检测关闭过程的完成\n * connectionstatechange: 连接状态（可以通过 connectionState 访问）已更改\n * datachannel: 有一个新的 RTCDataChannel 在远程对等方打开新数据通道之后可用. 此事件的类型是\n   RTCDataChannelEvent\n * error: 表示数据通道上发生错误的 RTCErrorEvent\n * error: 表示 RTCDtlsTransport 上发生错误的 RTCErrorEvent. 此错误将是 dtls-failure 或\n   fingerprint-failure\n * gatheringstatechange: RTCIceTransport 的收集状态已更改\n * icecandidate: 每当本地设备识别出一个新的 ICE 候选需要通过调用 setLocalDescription()\n   添加到本地对等方时，就会发送的 RTCPeerConnectionIceEvent\n * icecandidateerror: 表示在收集 ICE 候选时发生错误的 RTCPeerConnectionIceErrorEvent\n * iceconnectionstatechange: 在其 ICE 连接的状态（可通过 iceconnectionstate 属性访问）更改时，会发送给\n   RTCPeerConnection\n * icegatheringstatechange: 在其 ICE 收集状态（可通过 icegatheringstate 属性访问）更改时，会发送给\n   RTCPeerConnection\n * message: 在数据通道上收到消息. 该事件的类型为 MessageEvent\n * negotiationneeded: 通知 RTCPeerConnection 需要通过调用 createOffer()，然后是\n   setLocalDescription() 来执行会话协商\n * open: RTCDataChannel 的底层数据传输已成功打开或重新打开\n * selectedcandidatepairchange: RTCIceTransport 上的当前选择的 ICE 候选对已更改时触发的事件\n * track: 当成功协商了媒体流的流式传输后，将向 RTCPeerConnection 添加新轨道时，会发送类型为 RTCTrackevent 的\n   track 事件\n * signalingstatechange: 在其 signalingstate 更改时，会发送到对等连接. 这是由于调用\n   setLocalDescription() 或 setRemoteDescription() 引起的\n * statechange: RTCDtlsTransport 的状态已更改\n * statechange: RTCIceTransport 的状态已更改\n * statechange: RTCSctpTransport 的状态已更改\n * rtctransform: 编码的视频或音频帧已准备好在 worker 中使用转换流进行处理\n\n\nWebRTC 链接流程图#\n\n\n\n\n参考文档#\n\nMDN WebRTC","routePath":"/toolset/wiki/WebRTC","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"接口","id":"接口","depth":2,"charIndex":846},{"text":"事件","id":"事件","depth":2,"charIndex":1888},{"text":"WebRTC 链接流程图","id":"webrtc-链接流程图","depth":2,"charIndex":3525},{"text":"参考文档","id":"参考文档","depth":2,"charIndex":3543}],"domain":"","frontmatter":{},"version":""},{"id":41,"title":"JavaScript 数据类型","content":"#\n\n\n基本数据类型#\n\n> 基本数据类型是不可变的, 存储在栈内存中, 其值直接存储在变量中\n\n * Number\n * String\n * Boolean\n * Null\n * Undefined\n * Symbol\n * BigInt\n\n注意\n\nSymbol 虽然是一种基本数据类型, 但是他表现的和对象一样, 可以有方法\n\nBigInt 是一种特殊的数字类型, 用于处理超出常规 Number 类型安全整数范围的大整数\n\n诡异的基本数据类型\n\n基本数据类型也有特殊情况, 那就是能被 new 创建的类型, 例如 Number, String, Boolean\n\n这三个基本数据类型都可以通过 new 关键字创建实例, 然后他创建的实例虽然也是各自的类型, 但是他已经不是存储在栈内存中的变量了, 他存储的是一个指针,\n指向堆内存中的实例\n\n因为 new 关键字总会在内存中创建一块新的区域来存储\n\n让我们来看几个示例\n\n\n\n这就和 NaN(Not a Number) 有异曲同工之妙了 🤣 (不知道有没有人懂这个梗)\n\n\n引用数据类型#\n\n> 引用数据类型存储在堆内存中, 变量实际上存储的是指向这些数据的引用 (内存地址). 当复制引用类型变量时, 会创建一个新的引用指向同一个地址\n\n * Object\n * Function\n * Array\n * Date\n * RegExp\n * Error\n * Map\n * Set\n * WeakMap\n * WeakSet\n * Promise\n * Proxy\n * Reflect\n * ...","routePath":"/toolset/wiki/dataType","lang":"","toc":[{"text":"基本数据类型","id":"基本数据类型","depth":2,"charIndex":3},{"text":"引用数据类型","id":"引用数据类型","depth":2,"charIndex":465}],"domain":"","frontmatter":{},"version":""},{"id":42,"title":"介绍","content":"#\n\n这里都是一些专业百科内容","routePath":"/toolset/wiki/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"数组方法","content":"#\n\n\n遍历方法概览#\n\n * forEach\n * map\n * filter\n * find\n * findIndex\n * every\n * some\n * reduce\n\n\nforEach#\n\n> forEach 单纯就是用来遍历数组的(看起来很废物,但是巨常用)\n\n\n函数签名#\n\n\n\n\n函数签名解析#\n\n我们从函数签名可以看出他接受一个回调参数和一个回调参数的 this 指向,然后运行完之后啥都不返回\n\n\n特点#\n\n循环次数#\n\n和 for 循环等普通循环类似,但是他不会因为原数组的修改而改变循环次数\n\n\n\n\n\n对比普通循环\n\n\n\n\n\n可以看出如果我不在 i 等于 10 的时候中断循环的话那他就会无限循环下去\n\n当然你也可以用下面这种方式模拟 forEach 的循环次数\n\n\n\n\n\n\nmap#\n\n\nfilter#\n\n\nfind#\n\n\nfindIndex#\n\n\nevery#\n\n\nsome#\n\n\nreduce#","routePath":"/toolset/wiki/javascript/arrayFunc","lang":"","toc":[{"text":"遍历方法概览","id":"遍历方法概览","depth":2,"charIndex":3},{"text":"forEach","id":"foreach","depth":2,"charIndex":90},{"text":"函数签名","id":"函数签名","depth":3,"charIndex":138},{"text":"函数签名解析","id":"函数签名解析","depth":3,"charIndex":148},{"text":"特点","id":"特点","depth":3,"charIndex":209},{"text":"循环次数","id":"循环次数","depth":4,"charIndex":214},{"text":"map","id":"map","depth":2,"charIndex":350},{"text":"filter","id":"filter","depth":2,"charIndex":357},{"text":"find","id":"find","depth":2,"charIndex":367},{"text":"findIndex","id":"findindex","depth":2,"charIndex":375},{"text":"every","id":"every","depth":2,"charIndex":388},{"text":"some","id":"some","depth":2,"charIndex":397},{"text":"reduce","id":"reduce","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"数据类型转换","content":"#\n\n\n数据类型转换介绍#\n\nJavaScript是一种动态类型语言,变量没有类型限制,可以随时赋予任意值\n\n\n\n上面代码中a的值是数字还是字符串取决于y的值是真还是假,也就是说a在编译的时候并不知道具体的类型,只有在运行的时候才能得到y的值然后知道a的类型\n\n虽然变量的数据类型是不确定的,但是各种运算符对数据类型是有要求的 如果运算符发现,运算子的类型与预期不符,就会自动转换类型\n比如,减法运算符逾期左右两边的运算子都是数值,如果不是,就会自动将他们转为数值\n\n\n\n上面代码中,虽然是两个字符串相减,但是依然得到了1,因为JavaScript自动将他们的类型做了转换\n\n接下来我们就来聊一聊JavaScript中怎么进行数据类型的转换\n\n\n强制转换(显示类型转换)#\n\n强制类型转换主要使用Number(),String(),Boolean()这3个函数,手动将各种类型的值分别转换为数字,字符串或者布尔值\n\n\nNumber()#\n\n使用Number函数可以将任意的值转化为数值\n\n下面分成两种情况讨论,一种参数是原始类型的值,另一种是对象类型\n\n原始类型#\n\n原始类型的转换规则如下\n\n\n\n这里我们特别讨论一下字符串转数值\n\n我们知道,字符串转数值除了Number之外还可以用parseInt或者parseFloat\n\n咱们用过的都知道parseInt和parseFloat这两个方法把字符串解析为数值的时候都不怎么介意字符串中出现除数字外的字符\n\n\n\n我们从上面的5/6行也能看出他们俩只要遇到了非数值之后就不解析了,不管你后面有没有数值都不解析了,就好像一个不是舔狗的打工人一样,数值就是他的工钱,我帮你解析一\n个字符,你就要给我一份工钱,如果你这个字符不是数值,那就相当于你赖账了,那我就不给你继续上班了,这个灵魂比喻应该还是比较形象的,嘿嘿\n\n当然,虽然人家相对Number来说大气很多,但是也有特殊情况,就比如下面这两种\n\n\n\n你一开头就给人家一个非数字,别人什么好处都没有呢,当然直接就不给你解析了,随便甩给你一个NaN就完事了,你说是吧\n\n对象#\n\n转换对象我们可以先来看几个例子\n\n\n\n欸,第一个我理解,他是对象没法转成数值,那第二个和第三个都是数组,为什么一个可以转换另一个不能转换呢?\n\n好,现在我们就来探讨一下他为啥一下可以一下不可以吧\n\nNumber他去转换的时候,发现你给他的是个对象,那对象怎么转换成数值啊,没有办法把,这个时候他就会通过其他方法,把你的对象转为自己认识的原始类型\n\n 1. 调用对象自身的valueOf方法,如果返回原始类型的值,则直接对这个值使用Number函数\n 2. 如果调用valueOf返回的还是一个对象的话,就调用对象自身的toString方法,如果返回原始类型的值,则对该值调用Number方法\n 3. 报错\n\n这就是Number函数转换对象时的心路历程了,valueOf -> toString -> Error\n\n我们来模仿一下这个心路历程吧\n\n\n\n这段代码差不多就是他的心路历程了,一次次的确认他是不是object,就像你的对象一次次确认你是不是爱他一样,如果每次都是不爱,那我直接爆炸,只要有一次你爱我了,\n我就给你想要的(这么说好像舔狗)\n\n好了那我们现在来看看争议最大的数组吧\n\n\n\n是吧是吧,没有一点点争议对吧~\n\n当然这个toString和valueOf方法我们也可以自己重写掉,我这里拿对象来举个例子吧\n\n\n\n看到这大家会不会很好奇obj3为什么返回的是234而不是obj.valueOf返回的123呢?\n\n其实大家前面仔细看的话就会发现,Number类型转的心路历程中关心的一直都是你传入的那个对象,跟你的返回值没啥关系\n\n\n自动转换(隐式类型转换)#\n\nJavaScript遇到逾期和实际不符的地方就会进行数据类型的转换,我们先来看几个例子\n\n\n\n这些例子中运算符两侧的运算子都被转成了数值进行运算 从‘abc’ - 1这个例子里我们就可以看出它内部类型转换的时候调用的是Number方法\n\n当然一元运算符也会把运算子转换成数值\n\n","routePath":"/toolset/wiki/javascript/dataTransform","lang":"","toc":[{"text":"数据类型转换介绍","id":"数据类型转换介绍","depth":2,"charIndex":3},{"text":"强制转换(显示类型转换)","id":"强制转换显示类型转换","depth":2,"charIndex":322},{"text":"Number()","id":"number","depth":3,"charIndex":408},{"text":"原始类型","id":"原始类型","depth":4,"charIndex":476},{"text":"对象","id":"对象","depth":4,"charIndex":880},{"text":"自动转换(隐式类型转换)","id":"自动转换隐式类型转换","depth":2,"charIndex":1556}],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"执行栈和执行上下文","content":"#\n\n\n执行上下文#\n\n执行上下文(Execution Context),一句话概括就是“代码(全局代码,函数代码)执行前进行的准备工作”,也成为“执行上下文环境”\n\n直行JavaScript代码时,但代码执行进入一个环境时,就会为该环境创建一个执行上下文,他会在你运行代码强作一些准备工作,如确定作用域,创建局部变量对象\n\n具体做了什么我们慢慢来看,先来看下JavaScript执行环境有哪些\n\n\nJavaScript中执行环境#\n\n 1. 全局环境\n 2. 函数环境\n 3. eval函数环境(已不推荐使用)\n\n那么对应的执行上下文类型同样有3种\n\n 1. 全局执行上下文\n 2. 函数执行上下文\n 3. eval函数执行上下文\n\nJavaScript运行时首先会进入全局环境,对应会生成全局上下文\n程序代码中基本都会存在函数,那么调用函数就会进入函数执行环境,对应就会生成该函数的执行函数的下文\n\n由于代码中会声明多个函数,对应的函数执行上下文也会存在多个\n在JavaScript中,通过栈的存取方式来管理执行上下文,我们可称其为执行栈,或函数调用栈(Call Stack)","routePath":"/toolset/wiki/javascript/执行栈和执行上下文","lang":"","toc":[{"text":"执行上下文","id":"执行上下文","depth":2,"charIndex":3},{"text":"JavaScript中执行环境","id":"javascript中执行环境","depth":3,"charIndex":199}],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"产品需求文档","content":"#\n\n\n简介#\n\n产品需求文档 (Product Requirements Document, PRD) 是产品开发过程中至关重要的文件,\n他清晰地定义了产品的目标、功能、用户界面、性能需求等各个方面. 一个高质量的 PRD 能够帮助团队成员理解产品愿景, 确保开发过程中的每一步都与最终目标保持一致\n\n\n简易 PRD 模板#\n\n 1.  文档基本信息\n     1. 文档名称\n     2. 版本号\n     3. 便携人\n     4. 审阅人\n     5. 日期\n     6. 变更记录\n 2.  产品概述\n     1. 产品背景: 简要介绍产品开发的背、目的及预期解决的问题\n     2. 目标用户: 明确产品的目标用户群体及其特征\n     3. 产品愿景: 描述产品长期的发展方向和期望达成的市场地位\n 3.  用户需求分析\n     1. 用户画像: 详细描述典型用户的特征、需求、使用场景\n     2. 需求手机: 列出通过调研、访谈等方式筹集到的主要用户需求\n 4.  功能需求\n     1. 功能列表: 逐一列出产品所需实现的功能模块、可采用功能模块图辅助说明\n     2. 功能描述: 对每个功能进行详细描述, 包括功能的目的、使用流程、输入输出等\n 5.  用户界面与交互设计\n     1. 界面原型: 提供关键页面的线框画或原型设计, 展示界面布局、元素位置等\n     2. 交互说明: 描述用户与产品交互的流程, 包括响应时间、反括机制等\n 6.  性能需求\n     1. 相应时间: 对于用户操作的响应速度要求\n     2. 兼容性: 支持的设备、操作系统、浏览器等\n     3. 安全性: 数据加密、用户隐私保护等要求\n 7.  非功能性需求\n     1. 可用性: 易用性、可访问性要求\n     2. 可维护性: 系统维护、更新的需求\n     3. 可扩展性: 未来功能扩展的考虑\n 8.  里程碑与时间规划\n     1. 开发周期: 预计的开发、测试、上线时间表\n     2. 关键里程碑: 项目重要节点及验收标准\n 9.  风险评估与应对措施\n     1. 潜在风险: 识别项目实施中可能遇到的风险\n     2. 应对策略: 针对每个风险的预防和解决办法\n 10. 附录\n     1. 参考文件: 相关市场分析报告、竞品分析等\n     2. 术语表: 文档中使用的专业术语解释\n\n请根据项目的具体情况和团队协作习惯调整模板内容, 确保文档及全面又具有针对性. 此外, 考虑到协同编辑和版本管理的便利性, 建议使用在线文档工具 (如\nGoogle Docs、Confuence 或腾讯文档) 来撰写和管理 PRD","routePath":"/toolset/wiki/软件开发流程相关/PRD","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"简易 PRD 模板","id":"简易-prd-模板","depth":2,"charIndex":152}],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"测试用例","content":"#\n\n\n简介#\n\n测试用例 (Test Case, TC) 是软件测试的基础单元, 他是为验证特定功能或需求是否按预期工作而设计的一组详细的步骤和预期结果.\n测试用例是软件质量保证过程中的核心组成部分, 确保软件产品满足既定的质量标准、功能需求和用户期望\n\n\n目的#\n\n验证功能: 确保软件的各个功能正确无误的实现了需求规格说明书中的要求 发现缺陷: 通过系统的测试, 提前发现并定位软件中的错误或缺陷 确保质量:\n帮助提升软件的整体质量和稳定性, 减少用户在使用过程中遇到的问题 文档话: 为测试活动提供书面记录, 便于跟踪、重复执行和维护 促进沟通:\n作为开发人员、测试人员和项目管理人语啊之间沟通的桥梁, 确保对需求的理解一致\n\n\n组成要素#\n\n一个典型的测试用例通常包含一下几个关键部分:\n\n 1.  用例编号: 唯一的标识符, 方便管理和追踪\n 2.  标题: 简明地描述测试用例的目的或被测试的功能\n 3.  相关需求: 指出该测试用例对应的需求文档中的具体需求项\n 4.  前置条件: 执行测试用例前必须满足的条件或状态\n 5.  测试步骤: 详细的操作步骤, 指导测试执行者如何操作软件\n 6.  预期结果: 基于需求, 预期软件应展现的行为或输出结果\n 7.  实际结果: 执行测试后实际观察到的结果, 此部分在编写时留空, 执行时填写\n 8.  测试数据: 执行测试所需的特定输入值或数据集\n 9.  测试环境: 执行测试所需的硬件、软件配置和网络环境等\n 10. 执行结果: 通过/失败的判定, 以及任何发现的问题或异常记录\n 11. 测试者: 执行该测试用例的人员\n 12. 备注: 附加信息, 比如测试中的特殊注意事项、问题描述等\n\n\n编写原则#\n\n全面性: 确保覆盖所有功能、边界条件和异常流 可复用性: 设计的测试用例应该容易修改和复用使用 独立性: 尽量使每个测试用例独立于其他用例, 避免依赖 明确性:\n步骤和预期结果应当清晰、无歧义 可执行性: 确保测试用例能够在实际环境中被执行\n\n\n应用#\n\n测试用例不仅应用于功能测试, 还广泛应用于性能测试、安全测试、兼容测试等多个测试领域. 随着敏捷开发和 DevOps 的普及,\n自动化测试用例的编写和执行变得越来越重要, 能够显著提高测试效率和质量","routePath":"/toolset/wiki/软件开发流程相关/TC","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"目的","id":"目的","depth":2,"charIndex":129},{"text":"组成要素","id":"组成要素","depth":2,"charIndex":318},{"text":"编写原则","id":"编写原则","depth":2,"charIndex":730},{"text":"应用","id":"应用","depth":2,"charIndex":860}],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"软件开发流程","content":"#\n\n\n简介#\n\n软件开发的完整流程通常遵循一个标准化的模型, 旨在确保项目的高效执行和质量保证. 不同管队和项目可能会根据实际情况调整流程, 但大多数遵循基本步骤相似\n\n\n通用软件开发流程框架#\n\n> 结合了传统瀑布模型和现代敏捷开发的实践\n\n 1. 需求分析\n    1. 收集需求: 与利益相关者 (包括客户、用户、产品经理等) 沟通, 明确项目目标、功能需求和非功能需求\n    2. 需求分析: 整理和分析收集到的需求, 识别关键功能和约束条件, 制定需求规格说明书\n 2. 设计\n    1. 系统设计: 基于需求分析结果, 设计软件的结构和模块划分, 包括数据结构、接口设计、数据库设计等\n    2. 界面设计: 设计用户界面 (UI) 和用户体验 (UX), 制作原型或线框\n 3. 计划\n    1. 项目计划: 制定详细的项目计划, 包括时间表、资源分配、里程碑等\n    2. 风险管理: 识别潜在风险, 制定应对措施\n 4. 开发\n    1. 编码: 按照设计文档编写程序代码\n    2. 单元测试: 开发者对自己编写的代码进行单元测试, 确保每个模块按预期工作\n 5. 集成与测试\n    1. 集成: 将各个模块集成到一起, 形成完整的系统\n    2. 系统测试: 将全面的系统测试, 包括功能测试、性能测试、安全测试等\n    3. 用户验收测试 (UAT): 让最终用户或代表用户的一方进行测试, 确保软件满足实际使用需求\n 6. 部署\n    1. 准备部署: 包括环境配置、数据迁移、安装包制作等\n    2. 发布: 将软件部署到生产环境\n    3. 培训与文档: 为用户提供操作手册、帮助文档, 并进行必要的用户培训\n 7. 运维与监控\n    1. 监控: 持续监控软件运行状态, 收集性能指标和日志\n    2. 维护与更新: 根据用户反馈和监测结果, 进行软件的维护、修复漏洞、优化性能及版本迭代\n 8. 回顾与改进\n    1. 项目回顾: 项目结束后, 团队进行回顾会议, 总结经验教训\n    2. 持续改进: 根据反馈和市场变化, 不断迭代和优化产品\n\n现代敏捷开发, 如 Scrum 或 Kanban, 强调快速迭代, 持续交付和灵活应变. 在敏捷开发中, 需求分析、设计、开发、测试等阶段不是严格按照顺序进行,\n而是交叉重叠, 强调团队合作、快速反馈和适应性调整","routePath":"/toolset/wiki/软件开发流程相关/","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"通用软件开发流程框架","id":"通用软件开发流程框架","depth":2,"charIndex":86}],"domain":"","frontmatter":{},"version":""}]
"use strict";(self.webpackChunk_cmtlyt_toolset=self.webpackChunk_cmtlyt_toolset||[]).push([["2993"],{9246:function(e,n,s){s.r(n),s.d(n,{default:function(){return d}});var r=s(2676),i=s(453),c=s(2287);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",pre:"pre",div:"div"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"var",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#var",children:"#"}),"var"]}),"\n",(0,r.jsx)(c.Z,{defaultLocale:"zh-CN"}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"ES6+"})," 之前变量的声明使用的是 ",(0,r.jsx)(n.code,{children:"var"})," 关键字，但对于用 ",(0,r.jsx)(n.code,{children:"var"})," 声明的变量，不管声明位置在哪里都会被提升到当前作用域的顶端，也成为",(0,r.jsx)(n.strong,{children:"变量提升"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"如果是在函数体内声明的话就会提升到函数的最前面，如果是在全局作用域下就会提升到全局的最前面。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",meta:"",children:"function a() {\n    console.log(bar)\n    var bar = 'this is bar'\n}\na(); // undefined\n"})}),"\n",(0,r.jsxs)(n.p,{children:["为什么只会输出 ",(0,r.jsx)(n.code,{children:"undefined"})," ？因为 ",(0,r.jsx)(n.code,{children:"var"})," 只会做声明的提升，具体的赋值还是会等到执行到那一行才会执行。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",meta:"",children:"function a() {\n    console.log(bar)\n    var bar = 'this is bar'\n    console.log(bar)\n}\na();\n// undefined \n// this is bar\n"})}),"\n",(0,r.jsxs)(n.p,{children:["而在 ",(0,r.jsx)(n.code,{children:"ES6+"})," 之后，为了解决变量提升这个问题，也称为",(0,r.jsx)(n.strong,{children:"暂时性死区"}),"，新增了 ",(0,r.jsx)(n.code,{children:"let"})," 和 ",(0,r.jsx)(n.code,{children:"const"})," 声明变量的关键字。"]}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive info",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"INFO"}),(0,r.jsx)(n.div,{className:"rspress-directive-content",children:(0,r.jsx)(n.p,{children:"暂时性死区：在代码块内，使用 let 声明变量之前，该变量都是不可用的。"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",meta:"",children:"function a() {\n    console.log(bar);\n    let bar = 1\n}\na(); //ReferenceError: Cannot access 'bar' before initialization\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"const"})," 也不允许在声明之前使用变量， ",(0,r.jsx)(n.code,{children:"const"})," 是用于声明作用域的局部常量，常量的值不能通过 ",(0,r.jsx)(n.strong,{children:"赋值运算符(=)"})," 重新赋值改变，但如果常量是一个对象的话，它的属性可以被添加、更新或删除。"]}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive info",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"INFO"}),(0,r.jsxs)(n.div,{className:"rspress-directive-content",children:[(0,r.jsx)(n.p,{children:"关于为什么常量是对象的话就可以修改属性呢？"}),(0,r.jsxs)(n.p,{children:["因为在对象（引用数据类型）中，使用 ",(0,r.jsx)(n.code,{children:"const"})," 声明一个对象时声明的是一个对象的内存地址引用，不能通过",(0,r.jsx)(n.strong,{children:"赋值运算符"}),"重新赋值也就是不能改变这个引用去指向另一个对象。"]})]})]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(t,e)})):t(e)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["daily%2F%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.md"]={toc:[],title:"var",frontmatter:{}}},2287:function(e,n,s){s.d(n,{Z:function(){return d}});var r=s(2676),i=s(5271),c=s(2117);s(4986);let t={"zh-CN":e=>`预计阅读时间: ${e.minutes>=1?`${Math.ceil(e.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function a(e,n,s){let r=Object.keys(t).includes(n)?n:s;return t[r](e)}let d=e=>{let{defaultLocale:n="en-US"}=e,s=(0,c.Vi)().page.readingTimeData,t=(0,c.Jr)(),d=(0,c.e7)(),[l,o]=(0,i.useState)(a(s,t,n));return(0,i.useEffect)(()=>{o(a(s,t,n))},[t,s]),(0,r.jsx)("span",{"data-dark":String(d),className:"rp-reading-time",children:l})}}}]);
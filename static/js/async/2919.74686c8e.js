"use strict";(self.webpackChunk_cmtlyt_toolset=self.webpackChunk_cmtlyt_toolset||[]).push([["2919"],{200:function(n,e,r){r.r(e),r.d(e,{default:function(){return l}});var s=r(2676),c=r(453),t=r(2287);function i(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",pre:"pre",code:"code",ol:"ol",li:"li",img:"img"},(0,c.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"闭包",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#闭包",children:"#"}),"闭包"]}),"\n",(0,s.jsx)(t.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(e.h2,{id:"什么是闭包",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是闭包",children:"#"}),"什么是闭包"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures",rel:"noopener noreferrer",target:"_blank",children:"MDN"}),"的解释如下："]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"闭包"}),"（closure）是一个函数以及其捆绑的周边环境状态（",(0,s.jsx)(e.strong,{children:"lexical environment"}),"，",(0,s.jsx)(e.strong,{children:"词法环境"}),"）的引用的组合。换而言之，闭包让开发者可以从",(0,s.jsx)(e.strong,{children:"内部函数访问外部函数的作用域"}),"。在 JavaScript 中，闭包会随着函数的创建而被同时创建。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",meta:"",children:"function outer() {\n    const a = 0;\n\n    function inner() {\n        console.log('This is inner, a:', a);\n    }\n    return inner;\n}\nconst func = outer();\nfunc(); // This is inner, a: 0\n"})}),"\n",(0,s.jsx)(e.p,{children:"上面的例子中，inner 函数就是引用了外层函数 outer 作用域中的变量 a。"}),"\n",(0,s.jsx)(e.p,{children:"这种一般就是内部引用外部的变量，但如何在外部 引用 / 修改 内部的变量呢？"}),"\n",(0,s.jsxs)(e.h2,{id:"外部修改内部值",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#外部修改内部值",children:"#"}),"外部修改内部值"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"暴露一个修改接口"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",meta:"",children:"function outer() {\n    let a = 0;\n\n    function reset(num) {\n        a = num;\n        console.log('This is inner, a:', a);\n    }\n    return reset;\n}\nconst func = outer();\nfunc(1); // This is inner, a: 1\n"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"通过函数修改对象比如下面这道面试题："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",meta:"",children:"const ctrl = (() => {\n    const a = {\n        c: 'zzz'\n    }\n    return {\n        get(key) {\n            return a[key]\n        }\n    }\n})()\n\nctrl.get('b'); // 输出 1\n"})}),"\n",(0,s.jsxs)(e.p,{children:["由于 ctrl 他是一个立即执行函数，所以拿到的其实就是 ",(0,s.jsx)(e.code,{children:"get(key){return a[key]}"})," 这个函数，对于 a 对象来说就是一个闭包。如果要尝试在外面修改 a 对象的属性，那第一步就是要拿到 a 对象，在 js 中如果当前对象没有某个属性，就会往 ",(0,s.jsx)(e.a,{href:"#%E5%8E%9F%E5%9E%8B%E9%93%BE",children:"原型链"})," 上找，一直找到 ",(0,s.jsx)(e.code,{children:"Object.propotype"})," ，所以可以在直接在 ",(0,s.jsx)(e.code,{children:"Object"})," 的原型上加一个 b 属性。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",meta:"",children:"const ctrl = (() => {\n    const a = {\n        c: 'zzz'\n    }\n    return {\n        get(key) {\n            return a[key]\n        }\n    }\n})()\nObject.prototype.b = 1;\nctrl.get('b'); // 输出 1\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这样子就可以在找 ",(0,s.jsx)(e.code,{children:"a['b']"})," 的时候就会往原型链上找，由于 a 对象是通过字面量表示法。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",meta:"",children:"const a = {\n    c: 'zzz'\n}\n// 等价于下面\nconst a = new Object()\na.c = 'zzz'\n"})}),"\n",(0,s.jsxs)(e.p,{children:["当找 a['b'] 属性值的时候，a 中没有这个字段，所以会找到 ",(0,s.jsx)(e.code,{children:"Object.prototype"})," ，此时 ",(0,s.jsx)(e.code,{children:"Object.prototype.b = 1;"})," 就会返回数值 1。"]}),"\n",(0,s.jsx)(e.p,{children:"但这样子有一个弊端就是污染到了全局的对象，另外一个就是获取 ctrl 作用域里面的对象，然后在对象上加上 b 属性。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",meta:"",children:"const ctrl = (() => {\n    const a = {\n        c: 'zzz'\n    }\n    return {\n        get(key) {\n            return a[key]\n        }\n    }\n})()\nObject.defineProperty(Object.prototype, 'getThis', {\n    get() {\n        return this;\n    }\n})\nobj = ctrl.get('getThis'); // {c: 'zzz'}\nobj.b = 1; // {c: 'zzz', b: 1}\nctrl.get('b'); // 输出 1\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"原型链",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链",children:"#"}),"原型链"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"原型"}),"：在 JavaScript 中，每个函数对象都会有一个 ",(0,s.jsx)(e.code,{children:"prototype"})," 属性，这个属性指向函数的原型，也成为 ",(0,s.jsx)(e.strong,{children:"原型对象。"})]}),"\n",(0,s.jsxs)(e.p,{children:["原型上可以存放 ",(0,s.jsx)(e.strong,{children:"属性"})," 或 ",(0,s.jsx)(e.strong,{children:"方法"}),"，共享给 ",(0,s.jsx)(e.strong,{children:"实例对象"})," 使用，也可以做 ",(0,s.jsx)(e.strong,{children:"继承"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"原型链"}),"：对象都会有一个 ",(0,s.jsx)(e.code,{children:"__proto__"})," 属性指向对象的 原型对象，同时 原型对象 也是对象也有 ",(0,s.jsx)(e.code,{children:"__proto__"})," 指向原型对象的对象，因此每一个对象的 ",(0,s.jsx)(e.code,{children:"__proto__"})," 最终会指向到 ",(0,s.jsx)(e.code,{children:"Object.prototype.__proto__"})," 上面，表示原型链的顶端，而 ",(0,s.jsx)(e.code,{children:"Object.prototype.__proto__ = null。"})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"http://oss.snailuu.cn/picgo/1726407999439-3dbe1b70-6927-44ee-a2a5-d4be0f24ab0a.jpeg",alt:"img"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",meta:"",children:"const a = {\n    name: 'a',\n    pos: 1\n}\nconst b = {\n    pos: 1\n}\nb.name; // undefined\n"})}),"\n",(0,s.jsxs)(e.p,{children:["如果这样子打印 ",(0,s.jsx)(e.code,{children:"b.name"})," 的话，由于 b 中并没有 name 这个属性，所以会输出 undefined，但要是修改一下 b 的 ",(0,s.jsx)(e.code,{children:"__proto__"})," 指向呢？"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",meta:"",children:"const a = {\n    name: 'a',\n    pos: 1\n}\nconst b = {\n    pos: 1\n}\nb.__proto__ = a;\nb.name; // 'a'\n"})}),"\n",(0,s.jsxs)(e.p,{children:["还是上面的步骤，b 中没有 name 属性，所以他会往原型链 ",(0,s.jsx)(e.code,{children:"__proto__"})," 属性找，这时候就找到了 a，a 中有 name 字段，所以输出的是 a 中 name 的属性值。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"__proto__"})," 和 ",(0,s.jsx)(e.code,{children:"prototype"})," 区别："]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"__proto__"}),"是每个对象（包括普通对象和函数对象）都有的一个属性，指向创建该对象的构造函数的原型对象。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"prototype"}),"是构造函数独有属性，每个函数（作为构造函数）都有一个 ",(0,s.jsx)(e.code,{children:"prototype"}),"属性。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"__proto__"}),"是对象的内部属性，",(0,s.jsx)(e.code,{children:"prototype"}),"是构造函数的属性。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"原型链的相关方法："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Object.getPrototypeOf( ) ：查找一个对象的原型对象。"}),"\n",(0,s.jsx)(e.li,{children:"instanceof 操作符：判断一个对象是否是一个构造函数的实例。"}),"\n",(0,s.jsx)(e.li,{children:"isPrototypeOf( )：判断一个对象是否是另外一个对象的原型对象。"}),"\n",(0,s.jsx)(e.li,{children:"hasOwnProperty( )：判断一个属性是定义在对象本身还是从原型对象上继承得到的，如果是本身返回 true，如果是继承得到的返回 false。"}),"\n"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(i,n)})):i(n)}let l=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["daily%2F%E9%97%AD%E5%8C%85.md"]={toc:[{id:"什么是闭包",text:"什么是闭包",depth:2},{id:"外部修改内部值",text:"外部修改内部值",depth:2},{id:"原型链",text:"原型链",depth:2}],title:"闭包",frontmatter:{}}},2287:function(n,e,r){r.d(e,{Z:function(){return l}});var s=r(2676),c=r(5271),t=r(2117);r(4986);let i={"zh-CN":n=>`预计阅读时间: ${n.minutes>=1?`${Math.ceil(n.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":n=>`Estimated reading time: ${n.minutes>=1?`${Math.ceil(n.minutes)} minutes`:"less than 1 minute"}`};function a(n,e,r){let s=Object.keys(i).includes(e)?e:r;return i[s](n)}let l=n=>{let{defaultLocale:e="en-US"}=n,r=(0,t.Vi)().page.readingTimeData,i=(0,t.Jr)(),l=(0,t.e7)(),[o,d]=(0,c.useState)(a(r,i,e));return(0,c.useEffect)(()=>{d(a(r,i,e))},[i,r]),(0,s.jsx)("span",{"data-dark":String(l),className:"rp-reading-time",children:o})}}}]);
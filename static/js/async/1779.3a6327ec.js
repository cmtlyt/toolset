"use strict";(self.webpackChunk_cmtlyt_toolset=self.webpackChunk_cmtlyt_toolset||[]).push([["1779"],{380:function(e,n,r){r.r(n),r.d(n,{default:function(){return h}});var i=r(2676),s=r(453),l=r(2287);function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",ul:"ul",li:"li",code:"code",ol:"ol"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"elpis-core",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#elpis-core",children:"#"}),"elpis-core"]}),"\n",(0,i.jsx)(l.Z,{defaultLocale:"zh-CN"}),"\n",(0,i.jsxs)(n.h2,{id:"elpis-core-是什么",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#elpis-core-是什么",children:"#"}),"elpis-core 是什么?"]}),"\n",(0,i.jsx)(n.p,{children:"从表层来看 elpis-core 是一个服务端框架, 他是 egg 的阉割版, 基于 koa 后端框架开发, 提供了基础的接口服务"}),"\n",(0,i.jsxs)(n.h2,{id:"设计原则",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计原则",children:"#"}),"设计原则"]}),"\n",(0,i.jsx)(n.p,{children:"elpis-core 的底层能力还是 koa 提供的, 那 elpis-core 做了什么呢?"}),"\n",(0,i.jsxs)(n.p,{children:["我们每个开发者都有自己的开发习惯, 但是对于团队来说更需要的统一的风格和规范, 而不是每个开发者五花八门的",(0,i.jsx)(n.strong,{children:"魔法"})]}),"\n",(0,i.jsx)(n.p,{children:"为什么说是魔法呢? 因为你完全不知道其他人会把代码写在什么位置, 以及在什么位置添加或删除了什么"}),"\n",(0,i.jsx)(n.p,{children:"所以 elpis-core 就是为了解决这个问题而诞生的"}),"\n",(0,i.jsx)(n.p,{children:"实际上 elpis-core 也只是单纯的实现了一种后端框架编写的规范, 也叫约定."}),"\n",(0,i.jsx)(n.p,{children:"例如"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["在 ",(0,i.jsx)(n.code,{children:"app/controller"})," 路径下存放所有的 controller"]}),"\n",(0,i.jsxs)(n.li,{children:["在 ",(0,i.jsx)(n.code,{children:"app/service"})," 路径下存放所有的 service"]}),"\n",(0,i.jsxs)(n.li,{children:["在 ",(0,i.jsx)(n.code,{children:"app/middleware"})," 路径下存放所有的 middleware"]}),"\n",(0,i.jsxs)(n.li,{children:["在 ",(0,i.jsx)(n.code,{children:"app/extend"})," 路径下存放所有的 extend"]}),"\n",(0,i.jsxs)(n.li,{children:["在 ",(0,i.jsx)(n.code,{children:"app/config"})," 路径下存放所有的 config"]}),"\n",(0,i.jsxs)(n.li,{children:["在 ",(0,i.jsx)(n.code,{children:"app/router-schema"})," 路径下存放所有的 router-schema"]}),"\n",(0,i.jsxs)(n.li,{children:["在 ",(0,i.jsx)(n.code,{children:"app/router"})," 路径下存放所有的 router"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"这些都是 elpis-core 提供的约定, 使得 elpis-core 能够提供一种简单且统一的开发方式"}),"\n",(0,i.jsx)(n.p,{children:"elpis-core 会从这些目录读取对应的文件并且初始化代码, 然后挂载到 koa 的实例上, 这样我们就可以约束开发者的代码存放位置和编写规范, 然后对于报错来说也可以直接从对应的目录下找到问题, 从而提高开发效率"}),"\n",(0,i.jsxs)(n.h2,{id:"约定的好处",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#约定的好处",children:"#"}),"约定的好处"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["规范","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"代码的存放位置"}),"\n",(0,i.jsx)(n.li,{children:"代码的编写规范"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["统一","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"代码的挂载"}),"\n",(0,i.jsx)(n.li,{children:"代码的错误处理"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["效率","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"降低代码的维护成本"}),"\n",(0,i.jsx)(n.li,{children:"降低代码的理解成本"}),"\n",(0,i.jsx)(n.li,{children:"降低代码的上手难度"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"存在的问题",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#存在的问题",children:"#"}),"存在的问题"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"TS 支持较差"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"因为 elpis-core 是根据约定从对应目录读取文件初始化的, 所以对于 ts 的支持并不是特别好, 没法自动生成对于 ts 的类型描述"}),"\n",(0,i.jsxs)(n.p,{children:["例如: 现在有个 product 的 controller 被挂载在 ",(0,i.jsx)(n.code,{children:"app.controller.product"})," 上, 对于框架来说, product 具体类型是什么并不明确, 只有在开发的时候才会知道, 所以框架能做的就是, 告诉开发者, app 实例上存在一个 controller, 并且他的类型为 ",(0,i.jsx)(n.code,{children:"Record<string, Record<string, () => any>>"}),", 更细致的就只能是开发者在使用的时候去指定了, 或者直接在声明文件中覆盖框架对默认 controller 的类型描述"]}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"约定只是约定"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"elpis-core 并不对代码进行审查, 且约定并不是强制的, 部分开发者还是会在代码中引入一些黑盒逻辑或者过于跳跃的逻辑, 而这就会导致代码的维护成本增加"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(c,e)})):c(e)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["wiki%2Felpis%2Felpis-core.md"]={toc:[{id:"elpis-core-是什么",text:"elpis-core 是什么?",depth:2},{id:"设计原则",text:"设计原则",depth:2},{id:"约定的好处",text:"约定的好处",depth:2},{id:"存在的问题",text:"存在的问题",depth:2}],title:"elpis-core",frontmatter:{}}},2287:function(e,n,r){r.d(n,{Z:function(){return h}});var i=r(2676),s=r(5271),l=r(2117);r(4986);let c={"zh-CN":e=>`预计阅读时间: ${e.minutes>=1?`${Math.ceil(e.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function d(e,n,r){let i=Object.keys(c).includes(n)?n:r;return c[i](e)}let h=e=>{let{defaultLocale:n="en-US"}=e,r=(0,l.Vi)().page.readingTimeData,c=(0,l.Jr)(),h=(0,l.e7)(),[t,o]=(0,s.useState)(d(r,c,n));return(0,s.useEffect)(()=>{o(d(r,c,n))},[c,r]),(0,i.jsx)("span",{"data-dark":String(h),className:"rp-reading-time",children:t})}}}]);
# 作用域

在 `js` 中作用域主要就分为三种，全局作用域、函数作用域、块级作用域。

在浏览器环境中，全局作用域是挂载在 window 对象下的变量，在控制台中可以通过 `window.xxx` 来进行访问。

函数作用域就是在函数声明中定义的变量只有在函数内部才能访问，也称为作用域范围只有在当前函数中。

块级作用域是 `es6` 新增的，使用 `let` 和 `const` 声明的变量就只有在当前作用域中访问，而不会像 `var` 声明的变量一样会进行变量提升。

> 变量提升：javascript 在编译阶段的时候，js 引擎会搜集**所有**(作用域)的变量声明，并且提前让声明生效，也就是会先将变量/函数的声明提升到当前作用域顶部，并给其赋值( `undefined` )
>
> 暂时性死区：在使用 `let` 和 `const` 声明的变量之前去使用就会报错。
>
> 在严格模式下，使用 `var` 声明的变量就只会在函数作用域内被提升，不会提升到 `window` 上

> js 引擎创建执行上下文 -> var 声明的放**变量环境**， let, const 声明的放词法环境
>
> 寻找方式：从当前作用域下的词法环境的栈顶自顶向下寻找 -> 变量环境中寻找

`var` 声明一个**函数作用域**或**全局作用域**的变量。

`let` 声明一个可重新复制的块级作用域局部变量， `const` 声明用于块级作用域局部变量

比如

```javascript
if (true) {
    let a = 1;
    console.log(a); // 1
}
console.log(a); // undefined
```

------

```javascript
var a = 0;
console.log(a, window.a);
if (true) {
    console.log(a, window.a);
    a = 1;
    console.log(a, window.a);
    function a() {}
    console.log(a, window.a);
    a = 21;
    console.log(a, window.a);
    console.log('里面', a);
}
console.log('外面', a, window.a);
```

用 `var` 声明的变量提升到全局作用域中，此时 `window.a = 0` ，打印 `0 0`

进到 `if(){}` 作用域里面，有 `function a(){}` 的声明，此时 `a = function(){}` ，但函数声明只在当前的块级作用域有效，不会影响全局作用域，打印 `function a(){} 0`

重新将 `a` 赋值为 1，此时修改的是块级作用域里面的 `函数a` ，全局作用域下的 `a` 保持不变，打印 `1 0`

执行 `function a(){}` ，在 chrome 浏览器中，**函数声明会提升到全局作用域中同名的变量进行覆盖**，然后会将当前块级作用域中对应的值重新赋值给 `window.a` ，打印 `1 1`

重新将 `a` 赋值为 22，此时修改的还是块级作用域里面的 `a` ，打印 `21 1`

打印 `里面 21`

打印 `外面 1 1`

------

```javascript
var a = 0; {
    console.debug(1, a, window.a);
    a();
    console.debug(2, a, window.a);

    function a() {}
    console.debug(3, a, window.a);
    a = 1;
    console.debug(4, a, window.a);

    function a() {
        console.debug(5, a, window.a);
        a = 2;
    }
    console.debug(6, a, window.a)
}
console.debug(7, a, window.a);
```

声明变量 `a` ，进入到块级作用域中

块级作用域中有函数声明，提升到块级作用域顶层，后面声明的会覆盖前面声明的函数，此时 `a = function a(){console.debug(5, a, window.a);a = 2;}`

打印 `1 function 0`

调用方法 `a ()` 进到函数作用域中，函数作用域里面没有 `a` 的声明，往块级作用域找到 `a` 是一个函数，打印 `5 function 0` ，重新赋值 `a = 2` ，此时块级作用域的 `a` 就变成 2

打印 `2 2 0`

函数声明会先将当前 `a` 变量的值提升到全局作用域中同名的变量进行覆盖赋值，打印 `3 2 2`

`a`重新赋值为1，打印 `4 1 2`

函数声明再次将当前 `a` 变量的值赋值给全局变量，打印 `6 1 1`

最后出来之后打印 `7 1 1`



严格模式的限定：

-   不允许使用未声明的变量
-   不允许删除变量或对象
-   不允许删除函数
-   不允许变量重名
-   不允许使用八进制
-   不允许使用转义字符
-   不允许对只读属性赋值
-   不允许对一个使用 `getter` 方法读取的属性进行赋值
-   不允许删除一个不允许删除的属性
-   变量名不能使用 `eval` 字符串
-   变量名不能使用 `arguments` 字符串
